// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc --rs_out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `protos/mls_tools.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:mls_tools.MlsValidationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MlsValidationRequest {
    // message oneof groups
    pub payload: ::std::option::Option<mls_validation_request::Payload>,
    // special fields
    // @@protoc_insertion_point(special_field:mls_tools.MlsValidationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MlsValidationRequest {
    fn default() -> &'a MlsValidationRequest {
        <MlsValidationRequest as ::protobuf::Message>::default_instance()
    }
}

impl MlsValidationRequest {
    pub fn new() -> MlsValidationRequest {
        ::std::default::Default::default()
    }

    // .mls_tools.MlsValidationRequest.Passthrough passthrough = 1;

    pub fn passthrough(&self) -> &mls_validation_request::Passthrough {
        match self.payload {
            ::std::option::Option::Some(mls_validation_request::Payload::Passthrough(ref v)) => v,
            _ => <mls_validation_request::Passthrough as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_passthrough(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_passthrough(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(mls_validation_request::Payload::Passthrough(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_passthrough(&mut self, v: mls_validation_request::Passthrough) {
        self.payload = ::std::option::Option::Some(mls_validation_request::Payload::Passthrough(v))
    }

    // Mutable pointer to the field.
    pub fn mut_passthrough(&mut self) -> &mut mls_validation_request::Passthrough {
        if let ::std::option::Option::Some(mls_validation_request::Payload::Passthrough(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(mls_validation_request::Payload::Passthrough(mls_validation_request::Passthrough::new()));
        }
        match self.payload {
            ::std::option::Option::Some(mls_validation_request::Payload::Passthrough(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_passthrough(&mut self) -> mls_validation_request::Passthrough {
        if self.has_passthrough() {
            match self.payload.take() {
                ::std::option::Option::Some(mls_validation_request::Payload::Passthrough(v)) => v,
                _ => panic!(),
            }
        } else {
            mls_validation_request::Passthrough::new()
        }
    }

    // .mls_tools.MlsValidationRequest.InitialGroupInfoRequest initial_group_info_request = 2;

    pub fn initial_group_info_request(&self) -> &mls_validation_request::InitialGroupInfoRequest {
        match self.payload {
            ::std::option::Option::Some(mls_validation_request::Payload::InitialGroupInfoRequest(ref v)) => v,
            _ => <mls_validation_request::InitialGroupInfoRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_initial_group_info_request(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_initial_group_info_request(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(mls_validation_request::Payload::InitialGroupInfoRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_initial_group_info_request(&mut self, v: mls_validation_request::InitialGroupInfoRequest) {
        self.payload = ::std::option::Option::Some(mls_validation_request::Payload::InitialGroupInfoRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_initial_group_info_request(&mut self) -> &mut mls_validation_request::InitialGroupInfoRequest {
        if let ::std::option::Option::Some(mls_validation_request::Payload::InitialGroupInfoRequest(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(mls_validation_request::Payload::InitialGroupInfoRequest(mls_validation_request::InitialGroupInfoRequest::new()));
        }
        match self.payload {
            ::std::option::Option::Some(mls_validation_request::Payload::InitialGroupInfoRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_initial_group_info_request(&mut self) -> mls_validation_request::InitialGroupInfoRequest {
        if self.has_initial_group_info_request() {
            match self.payload.take() {
                ::std::option::Option::Some(mls_validation_request::Payload::InitialGroupInfoRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            mls_validation_request::InitialGroupInfoRequest::new()
        }
    }

    // .mls_tools.MlsValidationRequest.ExternalJoinRequest external_join_request = 3;

    pub fn external_join_request(&self) -> &mls_validation_request::ExternalJoinRequest {
        match self.payload {
            ::std::option::Option::Some(mls_validation_request::Payload::ExternalJoinRequest(ref v)) => v,
            _ => <mls_validation_request::ExternalJoinRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_external_join_request(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_external_join_request(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(mls_validation_request::Payload::ExternalJoinRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_external_join_request(&mut self, v: mls_validation_request::ExternalJoinRequest) {
        self.payload = ::std::option::Option::Some(mls_validation_request::Payload::ExternalJoinRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_external_join_request(&mut self) -> &mut mls_validation_request::ExternalJoinRequest {
        if let ::std::option::Option::Some(mls_validation_request::Payload::ExternalJoinRequest(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(mls_validation_request::Payload::ExternalJoinRequest(mls_validation_request::ExternalJoinRequest::new()));
        }
        match self.payload {
            ::std::option::Option::Some(mls_validation_request::Payload::ExternalJoinRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_external_join_request(&mut self) -> mls_validation_request::ExternalJoinRequest {
        if self.has_external_join_request() {
            match self.payload.take() {
                ::std::option::Option::Some(mls_validation_request::Payload::ExternalJoinRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            mls_validation_request::ExternalJoinRequest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, mls_validation_request::Passthrough>(
            "passthrough",
            MlsValidationRequest::has_passthrough,
            MlsValidationRequest::passthrough,
            MlsValidationRequest::mut_passthrough,
            MlsValidationRequest::set_passthrough,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, mls_validation_request::InitialGroupInfoRequest>(
            "initial_group_info_request",
            MlsValidationRequest::has_initial_group_info_request,
            MlsValidationRequest::initial_group_info_request,
            MlsValidationRequest::mut_initial_group_info_request,
            MlsValidationRequest::set_initial_group_info_request,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, mls_validation_request::ExternalJoinRequest>(
            "external_join_request",
            MlsValidationRequest::has_external_join_request,
            MlsValidationRequest::external_join_request,
            MlsValidationRequest::mut_external_join_request,
            MlsValidationRequest::set_external_join_request,
        ));
        oneofs.push(mls_validation_request::Payload::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MlsValidationRequest>(
            "MlsValidationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MlsValidationRequest {
    const NAME: &'static str = "MlsValidationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.payload = ::std::option::Option::Some(mls_validation_request::Payload::Passthrough(is.read_message()?));
                },
                18 => {
                    self.payload = ::std::option::Option::Some(mls_validation_request::Payload::InitialGroupInfoRequest(is.read_message()?));
                },
                26 => {
                    self.payload = ::std::option::Option::Some(mls_validation_request::Payload::ExternalJoinRequest(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &mls_validation_request::Payload::Passthrough(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &mls_validation_request::Payload::InitialGroupInfoRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &mls_validation_request::Payload::ExternalJoinRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &mls_validation_request::Payload::Passthrough(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &mls_validation_request::Payload::InitialGroupInfoRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &mls_validation_request::Payload::ExternalJoinRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MlsValidationRequest {
        MlsValidationRequest::new()
    }

    fn clear(&mut self) {
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MlsValidationRequest {
        static instance: MlsValidationRequest = MlsValidationRequest {
            payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MlsValidationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MlsValidationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MlsValidationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MlsValidationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MlsValidationRequest`
pub mod mls_validation_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:mls_tools.MlsValidationRequest.payload)
    pub enum Payload {
        // @@protoc_insertion_point(oneof_field:mls_tools.MlsValidationRequest.passthrough)
        Passthrough(Passthrough),
        // @@protoc_insertion_point(oneof_field:mls_tools.MlsValidationRequest.initial_group_info_request)
        InitialGroupInfoRequest(InitialGroupInfoRequest),
        // @@protoc_insertion_point(oneof_field:mls_tools.MlsValidationRequest.external_join_request)
        ExternalJoinRequest(ExternalJoinRequest),
    }

    impl ::protobuf::Oneof for Payload {
    }

    impl ::protobuf::OneofFull for Payload {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::MlsValidationRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("payload").unwrap()).clone()
        }
    }

    impl Payload {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Payload>("payload")
        }
    }
    ///  for testing purposes, always returns valid
    // @@protoc_insertion_point(message:mls_tools.MlsValidationRequest.Passthrough)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Passthrough {
        // special fields
        // @@protoc_insertion_point(special_field:mls_tools.MlsValidationRequest.Passthrough.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Passthrough {
        fn default() -> &'a Passthrough {
            <Passthrough as ::protobuf::Message>::default_instance()
        }
    }

    impl Passthrough {
        pub fn new() -> Passthrough {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Passthrough>(
                "MlsValidationRequest.Passthrough",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Passthrough {
        const NAME: &'static str = "Passthrough";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Passthrough {
            Passthrough::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Passthrough {
            static instance: Passthrough = Passthrough {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Passthrough {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MlsValidationRequest.Passthrough").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Passthrough {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Passthrough {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:mls_tools.MlsValidationRequest.InitialGroupInfoRequest)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct InitialGroupInfoRequest {
        // message fields
        // @@protoc_insertion_point(field:mls_tools.MlsValidationRequest.InitialGroupInfoRequest.group_info_message)
        pub group_info_message: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:mls_tools.MlsValidationRequest.InitialGroupInfoRequest.external_group_snapshot)
        pub external_group_snapshot: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:mls_tools.MlsValidationRequest.InitialGroupInfoRequest.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a InitialGroupInfoRequest {
        fn default() -> &'a InitialGroupInfoRequest {
            <InitialGroupInfoRequest as ::protobuf::Message>::default_instance()
        }
    }

    impl InitialGroupInfoRequest {
        pub fn new() -> InitialGroupInfoRequest {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "group_info_message",
                |m: &InitialGroupInfoRequest| { &m.group_info_message },
                |m: &mut InitialGroupInfoRequest| { &mut m.group_info_message },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "external_group_snapshot",
                |m: &InitialGroupInfoRequest| { &m.external_group_snapshot },
                |m: &mut InitialGroupInfoRequest| { &mut m.external_group_snapshot },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InitialGroupInfoRequest>(
                "MlsValidationRequest.InitialGroupInfoRequest",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for InitialGroupInfoRequest {
        const NAME: &'static str = "InitialGroupInfoRequest";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.group_info_message = is.read_bytes()?;
                    },
                    18 => {
                        self.external_group_snapshot = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.group_info_message.is_empty() {
                my_size += ::protobuf::rt::bytes_size(1, &self.group_info_message);
            }
            if !self.external_group_snapshot.is_empty() {
                my_size += ::protobuf::rt::bytes_size(2, &self.external_group_snapshot);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.group_info_message.is_empty() {
                os.write_bytes(1, &self.group_info_message)?;
            }
            if !self.external_group_snapshot.is_empty() {
                os.write_bytes(2, &self.external_group_snapshot)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> InitialGroupInfoRequest {
            InitialGroupInfoRequest::new()
        }

        fn clear(&mut self) {
            self.group_info_message.clear();
            self.external_group_snapshot.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static InitialGroupInfoRequest {
            static instance: InitialGroupInfoRequest = InitialGroupInfoRequest {
                group_info_message: ::std::vec::Vec::new(),
                external_group_snapshot: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for InitialGroupInfoRequest {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MlsValidationRequest.InitialGroupInfoRequest").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for InitialGroupInfoRequest {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for InitialGroupInfoRequest {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:mls_tools.MlsValidationRequest.ExternalJoinRequest)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ExternalJoinRequest {
        // message fields
        // @@protoc_insertion_point(field:mls_tools.MlsValidationRequest.ExternalJoinRequest.external_group_snapshot)
        pub external_group_snapshot: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:mls_tools.MlsValidationRequest.ExternalJoinRequest.commits)
        pub commits: ::std::vec::Vec<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:mls_tools.MlsValidationRequest.ExternalJoinRequest.proposed_external_join_info_message)
        pub proposed_external_join_info_message: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:mls_tools.MlsValidationRequest.ExternalJoinRequest.proposed_external_join_commit)
        pub proposed_external_join_commit: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:mls_tools.MlsValidationRequest.ExternalJoinRequest.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ExternalJoinRequest {
        fn default() -> &'a ExternalJoinRequest {
            <ExternalJoinRequest as ::protobuf::Message>::default_instance()
        }
    }

    impl ExternalJoinRequest {
        pub fn new() -> ExternalJoinRequest {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "external_group_snapshot",
                |m: &ExternalJoinRequest| { &m.external_group_snapshot },
                |m: &mut ExternalJoinRequest| { &mut m.external_group_snapshot },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "commits",
                |m: &ExternalJoinRequest| { &m.commits },
                |m: &mut ExternalJoinRequest| { &mut m.commits },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "proposed_external_join_info_message",
                |m: &ExternalJoinRequest| { &m.proposed_external_join_info_message },
                |m: &mut ExternalJoinRequest| { &mut m.proposed_external_join_info_message },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "proposed_external_join_commit",
                |m: &ExternalJoinRequest| { &m.proposed_external_join_commit },
                |m: &mut ExternalJoinRequest| { &mut m.proposed_external_join_commit },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExternalJoinRequest>(
                "MlsValidationRequest.ExternalJoinRequest",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ExternalJoinRequest {
        const NAME: &'static str = "ExternalJoinRequest";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.external_group_snapshot = is.read_bytes()?;
                    },
                    18 => {
                        self.commits.push(is.read_bytes()?);
                    },
                    26 => {
                        self.proposed_external_join_info_message = is.read_bytes()?;
                    },
                    34 => {
                        self.proposed_external_join_commit = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.external_group_snapshot.is_empty() {
                my_size += ::protobuf::rt::bytes_size(1, &self.external_group_snapshot);
            }
            for value in &self.commits {
                my_size += ::protobuf::rt::bytes_size(2, &value);
            };
            if !self.proposed_external_join_info_message.is_empty() {
                my_size += ::protobuf::rt::bytes_size(3, &self.proposed_external_join_info_message);
            }
            if !self.proposed_external_join_commit.is_empty() {
                my_size += ::protobuf::rt::bytes_size(4, &self.proposed_external_join_commit);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.external_group_snapshot.is_empty() {
                os.write_bytes(1, &self.external_group_snapshot)?;
            }
            for v in &self.commits {
                os.write_bytes(2, &v)?;
            };
            if !self.proposed_external_join_info_message.is_empty() {
                os.write_bytes(3, &self.proposed_external_join_info_message)?;
            }
            if !self.proposed_external_join_commit.is_empty() {
                os.write_bytes(4, &self.proposed_external_join_commit)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ExternalJoinRequest {
            ExternalJoinRequest::new()
        }

        fn clear(&mut self) {
            self.external_group_snapshot.clear();
            self.commits.clear();
            self.proposed_external_join_info_message.clear();
            self.proposed_external_join_commit.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ExternalJoinRequest {
            static instance: ExternalJoinRequest = ExternalJoinRequest {
                external_group_snapshot: ::std::vec::Vec::new(),
                commits: ::std::vec::Vec::new(),
                proposed_external_join_info_message: ::std::vec::Vec::new(),
                proposed_external_join_commit: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ExternalJoinRequest {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MlsValidationRequest.ExternalJoinRequest").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ExternalJoinRequest {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ExternalJoinRequest {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:mls_tools.MlsValidationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MlsValidationResponse {
    // message fields
    // @@protoc_insertion_point(field:mls_tools.MlsValidationResponse.result)
    pub result: ::protobuf::EnumOrUnknown<mls_validation_response::ValidationResult>,
    // special fields
    // @@protoc_insertion_point(special_field:mls_tools.MlsValidationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MlsValidationResponse {
    fn default() -> &'a MlsValidationResponse {
        <MlsValidationResponse as ::protobuf::Message>::default_instance()
    }
}

impl MlsValidationResponse {
    pub fn new() -> MlsValidationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "result",
            |m: &MlsValidationResponse| { &m.result },
            |m: &mut MlsValidationResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MlsValidationResponse>(
            "MlsValidationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MlsValidationResponse {
    const NAME: &'static str = "MlsValidationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.result != ::protobuf::EnumOrUnknown::new(mls_validation_response::ValidationResult::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(1, self.result.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.result != ::protobuf::EnumOrUnknown::new(mls_validation_response::ValidationResult::UNKNOWN) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.result))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MlsValidationResponse {
        MlsValidationResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::protobuf::EnumOrUnknown::new(mls_validation_response::ValidationResult::UNKNOWN);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MlsValidationResponse {
        static instance: MlsValidationResponse = MlsValidationResponse {
            result: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MlsValidationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MlsValidationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MlsValidationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MlsValidationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MlsValidationResponse`
pub mod mls_validation_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:mls_tools.MlsValidationResponse.ValidationResult)
    pub enum ValidationResult {
        // @@protoc_insertion_point(enum_value:mls_tools.MlsValidationResponse.ValidationResult.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:mls_tools.MlsValidationResponse.ValidationResult.VALID)
        VALID = 1,
        // @@protoc_insertion_point(enum_value:mls_tools.MlsValidationResponse.ValidationResult.INVALID_GROUP_INFO)
        INVALID_GROUP_INFO = 2,
        // @@protoc_insertion_point(enum_value:mls_tools.MlsValidationResponse.ValidationResult.INVALID_EXTERNAL_GROUP)
        INVALID_EXTERNAL_GROUP = 3,
        // @@protoc_insertion_point(enum_value:mls_tools.MlsValidationResponse.ValidationResult.INVALID_EXTERNAL_GROUP_EPOCH)
        INVALID_EXTERNAL_GROUP_EPOCH = 4,
        // @@protoc_insertion_point(enum_value:mls_tools.MlsValidationResponse.ValidationResult.INVALID_EXTERNAL_GROUP_MISSING_TREE)
        INVALID_EXTERNAL_GROUP_MISSING_TREE = 5,
        // @@protoc_insertion_point(enum_value:mls_tools.MlsValidationResponse.ValidationResult.INVALID_GROUP_INFO_EPOCH)
        INVALID_GROUP_INFO_EPOCH = 6,
        // @@protoc_insertion_point(enum_value:mls_tools.MlsValidationResponse.ValidationResult.INVALID_GROUP_INFO_MISSING_PUB_KEY_EXTENSION)
        INVALID_GROUP_INFO_MISSING_PUB_KEY_EXTENSION = 7,
        // @@protoc_insertion_point(enum_value:mls_tools.MlsValidationResponse.ValidationResult.INVALID_COMMIT)
        INVALID_COMMIT = 8,
    }

    impl ::protobuf::Enum for ValidationResult {
        const NAME: &'static str = "ValidationResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ValidationResult> {
            match value {
                0 => ::std::option::Option::Some(ValidationResult::UNKNOWN),
                1 => ::std::option::Option::Some(ValidationResult::VALID),
                2 => ::std::option::Option::Some(ValidationResult::INVALID_GROUP_INFO),
                3 => ::std::option::Option::Some(ValidationResult::INVALID_EXTERNAL_GROUP),
                4 => ::std::option::Option::Some(ValidationResult::INVALID_EXTERNAL_GROUP_EPOCH),
                5 => ::std::option::Option::Some(ValidationResult::INVALID_EXTERNAL_GROUP_MISSING_TREE),
                6 => ::std::option::Option::Some(ValidationResult::INVALID_GROUP_INFO_EPOCH),
                7 => ::std::option::Option::Some(ValidationResult::INVALID_GROUP_INFO_MISSING_PUB_KEY_EXTENSION),
                8 => ::std::option::Option::Some(ValidationResult::INVALID_COMMIT),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ValidationResult> {
            match str {
                "UNKNOWN" => ::std::option::Option::Some(ValidationResult::UNKNOWN),
                "VALID" => ::std::option::Option::Some(ValidationResult::VALID),
                "INVALID_GROUP_INFO" => ::std::option::Option::Some(ValidationResult::INVALID_GROUP_INFO),
                "INVALID_EXTERNAL_GROUP" => ::std::option::Option::Some(ValidationResult::INVALID_EXTERNAL_GROUP),
                "INVALID_EXTERNAL_GROUP_EPOCH" => ::std::option::Option::Some(ValidationResult::INVALID_EXTERNAL_GROUP_EPOCH),
                "INVALID_EXTERNAL_GROUP_MISSING_TREE" => ::std::option::Option::Some(ValidationResult::INVALID_EXTERNAL_GROUP_MISSING_TREE),
                "INVALID_GROUP_INFO_EPOCH" => ::std::option::Option::Some(ValidationResult::INVALID_GROUP_INFO_EPOCH),
                "INVALID_GROUP_INFO_MISSING_PUB_KEY_EXTENSION" => ::std::option::Option::Some(ValidationResult::INVALID_GROUP_INFO_MISSING_PUB_KEY_EXTENSION),
                "INVALID_COMMIT" => ::std::option::Option::Some(ValidationResult::INVALID_COMMIT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ValidationResult] = &[
            ValidationResult::UNKNOWN,
            ValidationResult::VALID,
            ValidationResult::INVALID_GROUP_INFO,
            ValidationResult::INVALID_EXTERNAL_GROUP,
            ValidationResult::INVALID_EXTERNAL_GROUP_EPOCH,
            ValidationResult::INVALID_EXTERNAL_GROUP_MISSING_TREE,
            ValidationResult::INVALID_GROUP_INFO_EPOCH,
            ValidationResult::INVALID_GROUP_INFO_MISSING_PUB_KEY_EXTENSION,
            ValidationResult::INVALID_COMMIT,
        ];
    }

    impl ::protobuf::EnumFull for ValidationResult {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MlsValidationResponse.ValidationResult").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ValidationResult {
        fn default() -> Self {
            ValidationResult::UNKNOWN
        }
    }

    impl ValidationResult {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ValidationResult>("MlsValidationResponse.ValidationResult")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16protos/mls_tools.proto\x12\tmls_tools\"\xe0\x05\n\x14MlsValidation\
    Request\x12O\n\x0bpassthrough\x18\x01\x20\x01(\x0b2+.mls_tools.MlsValida\
    tionRequest.PassthroughH\0R\x0bpassthrough\x12v\n\x1ainitial_group_info_\
    request\x18\x02\x20\x01(\x0b27.mls_tools.MlsValidationRequest.InitialGro\
    upInfoRequestH\0R\x17initialGroupInfoRequest\x12i\n\x15external_join_req\
    uest\x18\x03\x20\x01(\x0b23.mls_tools.MlsValidationRequest.ExternalJoinR\
    equestH\0R\x13externalJoinRequest\x1a\r\n\x0bPassthrough\x1a\x7f\n\x17In\
    itialGroupInfoRequest\x12,\n\x12group_info_message\x18\x01\x20\x01(\x0cR\
    \x10groupInfoMessage\x126\n\x17external_group_snapshot\x18\x02\x20\x01(\
    \x0cR\x15externalGroupSnapshot\x1a\xf8\x01\n\x13ExternalJoinRequest\x126\
    \n\x17external_group_snapshot\x18\x01\x20\x01(\x0cR\x15externalGroupSnap\
    shot\x12\x18\n\x07commits\x18\x02\x20\x03(\x0cR\x07commits\x12L\n#propos\
    ed_external_join_info_message\x18\x03\x20\x01(\x0cR\x1fproposedExternalJ\
    oinInfoMessage\x12A\n\x1dproposed_external_join_commit\x18\x04\x20\x01(\
    \x0cR\x1aproposedExternalJoinCommitB\t\n\x07payload\"\xf2\x02\n\x15MlsVa\
    lidationResponse\x12I\n\x06result\x18\x01\x20\x01(\x0e21.mls_tools.MlsVa\
    lidationResponse.ValidationResultR\x06result\"\x8d\x02\n\x10ValidationRe\
    sult\x12\x0b\n\x07UNKNOWN\x10\0\x12\t\n\x05VALID\x10\x01\x12\x16\n\x12IN\
    VALID_GROUP_INFO\x10\x02\x12\x1a\n\x16INVALID_EXTERNAL_GROUP\x10\x03\x12\
    \x20\n\x1cINVALID_EXTERNAL_GROUP_EPOCH\x10\x04\x12'\n#INVALID_EXTERNAL_G\
    ROUP_MISSING_TREE\x10\x05\x12\x1c\n\x18INVALID_GROUP_INFO_EPOCH\x10\x06\
    \x120\n,INVALID_GROUP_INFO_MISSING_PUB_KEY_EXTENSION\x10\x07\x12\x12\n\
    \x0eINVALID_COMMIT\x10\x08B\rZ\x0b./mls_toolsJ\xa7\n\n\x06\x12\x04\0\0+\
    \x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\x12\n\
    \x08\n\x01\x08\x12\x03\x02\0\"\n\t\n\x02\x08\x0b\x12\x03\x02\0\"\n\n\n\
    \x02\x04\0\x12\x04\x04\0\x1a\x01\n\n\n\x03\x04\0\x01\x12\x03\x04\x08\x1c\
    \n9\n\x04\x04\0\x03\0\x12\x03\x07\x04\x1a\x1a,\x20for\x20testing\x20purp\
    oses,\x20always\x20returns\x20valid\n\n\x0c\n\x05\x04\0\x03\0\x01\x12\
    \x03\x07\x0c\x17\n\x0c\n\x04\x04\0\x03\x01\x12\x04\t\x04\x0c\x05\n\x0c\n\
    \x05\x04\0\x03\x01\x01\x12\x03\t\x0c#\n\r\n\x06\x04\0\x03\x01\x02\0\x12\
    \x03\n\x08%\n\x0e\n\x07\x04\0\x03\x01\x02\0\x05\x12\x03\n\x08\r\n\x0e\n\
    \x07\x04\0\x03\x01\x02\0\x01\x12\x03\n\x0e\x20\n\x0e\n\x07\x04\0\x03\x01\
    \x02\0\x03\x12\x03\n#$\n\r\n\x06\x04\0\x03\x01\x02\x01\x12\x03\x0b\x08*\
    \n\x0e\n\x07\x04\0\x03\x01\x02\x01\x05\x12\x03\x0b\x08\r\n\x0e\n\x07\x04\
    \0\x03\x01\x02\x01\x01\x12\x03\x0b\x0e%\n\x0e\n\x07\x04\0\x03\x01\x02\
    \x01\x03\x12\x03\x0b()\n\x0c\n\x04\x04\0\x03\x02\x12\x04\x0e\x04\x13\x05\
    \n\x0c\n\x05\x04\0\x03\x02\x01\x12\x03\x0e\x0c\x1f\n\r\n\x06\x04\0\x03\
    \x02\x02\0\x12\x03\x0f\x08*\n\x0e\n\x07\x04\0\x03\x02\x02\0\x05\x12\x03\
    \x0f\x08\r\n\x0e\n\x07\x04\0\x03\x02\x02\0\x01\x12\x03\x0f\x0e%\n\x0e\n\
    \x07\x04\0\x03\x02\x02\0\x03\x12\x03\x0f()\n\r\n\x06\x04\0\x03\x02\x02\
    \x01\x12\x03\x10\x08#\n\x0e\n\x07\x04\0\x03\x02\x02\x01\x04\x12\x03\x10\
    \x08\x10\n\x0e\n\x07\x04\0\x03\x02\x02\x01\x05\x12\x03\x10\x11\x16\n\x0e\
    \n\x07\x04\0\x03\x02\x02\x01\x01\x12\x03\x10\x17\x1e\n\x0e\n\x07\x04\0\
    \x03\x02\x02\x01\x03\x12\x03\x10!\"\n\r\n\x06\x04\0\x03\x02\x02\x02\x12\
    \x03\x11\x086\n\x0e\n\x07\x04\0\x03\x02\x02\x02\x05\x12\x03\x11\x08\r\n\
    \x0e\n\x07\x04\0\x03\x02\x02\x02\x01\x12\x03\x11\x0e1\n\x0e\n\x07\x04\0\
    \x03\x02\x02\x02\x03\x12\x03\x1145\n\r\n\x06\x04\0\x03\x02\x02\x03\x12\
    \x03\x12\x080\n\x0e\n\x07\x04\0\x03\x02\x02\x03\x05\x12\x03\x12\x08\r\n\
    \x0e\n\x07\x04\0\x03\x02\x02\x03\x01\x12\x03\x12\x0e+\n\x0e\n\x07\x04\0\
    \x03\x02\x02\x03\x03\x12\x03\x12./\n\x0c\n\x04\x04\0\x08\0\x12\x04\x15\
    \x04\x19\x05\n\x0c\n\x05\x04\0\x08\0\x01\x12\x03\x15\n\x11\n\x0b\n\x04\
    \x04\0\x02\0\x12\x03\x16\x08$\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x16\
    \x08\x13\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x16\x14\x1f\n\x0c\n\x05\x04\
    \0\x02\0\x03\x12\x03\x16\"#\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x17\x08?\n\
    \x0c\n\x05\x04\0\x02\x01\x06\x12\x03\x17\x08\x1f\n\x0c\n\x05\x04\0\x02\
    \x01\x01\x12\x03\x17\x20:\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x17=>\n\
    \x0b\n\x04\x04\0\x02\x02\x12\x03\x18\x086\n\x0c\n\x05\x04\0\x02\x02\x06\
    \x12\x03\x18\x08\x1b\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x18\x1c1\n\
    \x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x1845\n\n\n\x02\x04\x01\x12\x04\x1c\
    \0+\x01\n\n\n\x03\x04\x01\x01\x12\x03\x1c\x08\x1d\n\x0c\n\x04\x04\x01\
    \x04\0\x12\x04\x1e\x04(\x05\n\x0c\n\x05\x04\x01\x04\0\x01\x12\x03\x1e\t\
    \x19\n\r\n\x06\x04\x01\x04\0\x02\0\x12\x03\x1f\x08\x14\n\x0e\n\x07\x04\
    \x01\x04\0\x02\0\x01\x12\x03\x1f\x08\x0f\n\x0e\n\x07\x04\x01\x04\0\x02\0\
    \x02\x12\x03\x1f\x12\x13\n\r\n\x06\x04\x01\x04\0\x02\x01\x12\x03\x20\x08\
    \x12\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x01\x12\x03\x20\x08\r\n\x0e\n\x07\
    \x04\x01\x04\0\x02\x01\x02\x12\x03\x20\x10\x11\n\r\n\x06\x04\x01\x04\0\
    \x02\x02\x12\x03!\x08\x1f\n\x0e\n\x07\x04\x01\x04\0\x02\x02\x01\x12\x03!\
    \x08\x1a\n\x0e\n\x07\x04\x01\x04\0\x02\x02\x02\x12\x03!\x1d\x1e\n\r\n\
    \x06\x04\x01\x04\0\x02\x03\x12\x03\"\x08#\n\x0e\n\x07\x04\x01\x04\0\x02\
    \x03\x01\x12\x03\"\x08\x1e\n\x0e\n\x07\x04\x01\x04\0\x02\x03\x02\x12\x03\
    \"!\"\n\r\n\x06\x04\x01\x04\0\x02\x04\x12\x03#\x08)\n\x0e\n\x07\x04\x01\
    \x04\0\x02\x04\x01\x12\x03#\x08$\n\x0e\n\x07\x04\x01\x04\0\x02\x04\x02\
    \x12\x03#'(\n\r\n\x06\x04\x01\x04\0\x02\x05\x12\x03$\x080\n\x0e\n\x07\
    \x04\x01\x04\0\x02\x05\x01\x12\x03$\x08+\n\x0e\n\x07\x04\x01\x04\0\x02\
    \x05\x02\x12\x03$./\n\r\n\x06\x04\x01\x04\0\x02\x06\x12\x03%\x08%\n\x0e\
    \n\x07\x04\x01\x04\0\x02\x06\x01\x12\x03%\x08\x20\n\x0e\n\x07\x04\x01\
    \x04\0\x02\x06\x02\x12\x03%#$\n\r\n\x06\x04\x01\x04\0\x02\x07\x12\x03&\
    \x089\n\x0e\n\x07\x04\x01\x04\0\x02\x07\x01\x12\x03&\x084\n\x0e\n\x07\
    \x04\x01\x04\0\x02\x07\x02\x12\x03&78\n\r\n\x06\x04\x01\x04\0\x02\x08\
    \x12\x03'\x08\x1b\n\x0e\n\x07\x04\x01\x04\0\x02\x08\x01\x12\x03'\x08\x16\
    \n\x0e\n\x07\x04\x01\x04\0\x02\x08\x02\x12\x03'\x19\x1a\n\x0b\n\x04\x04\
    \x01\x02\0\x12\x03*\x04\x20\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03*\x04\
    \x14\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03*\x15\x1b\n\x0c\n\x05\x04\x01\
    \x02\0\x03\x12\x03*\x1e\x1fb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(5);
            messages.push(MlsValidationRequest::generated_message_descriptor_data());
            messages.push(MlsValidationResponse::generated_message_descriptor_data());
            messages.push(mls_validation_request::Passthrough::generated_message_descriptor_data());
            messages.push(mls_validation_request::InitialGroupInfoRequest::generated_message_descriptor_data());
            messages.push(mls_validation_request::ExternalJoinRequest::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(mls_validation_response::ValidationResult::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
