// @generated by protoc-gen-es v1.9.0 with parameter "target=ts"
// @generated from file protocol.proto (package river, syntax proto3)
/* eslint-disable */
// @ts-nocheck
import { Empty, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
/**
 * @generated from enum river.SyncOp
 */
export var SyncOp;
(function (SyncOp) {
    /**
     * @generated from enum value: SYNC_UNSPECIFIED = 0;
     */
    SyncOp[SyncOp["SYNC_UNSPECIFIED"] = 0] = "SYNC_UNSPECIFIED";
    /**
     * new sync
     *
     * @generated from enum value: SYNC_NEW = 1;
     */
    SyncOp[SyncOp["SYNC_NEW"] = 1] = "SYNC_NEW";
    /**
     * close the sync
     *
     * @generated from enum value: SYNC_CLOSE = 2;
     */
    SyncOp[SyncOp["SYNC_CLOSE"] = 2] = "SYNC_CLOSE";
    /**
     * update from server
     *
     * @generated from enum value: SYNC_UPDATE = 3;
     */
    SyncOp[SyncOp["SYNC_UPDATE"] = 3] = "SYNC_UPDATE";
    /**
     * respond to the ping message from the client.
     *
     * @generated from enum value: SYNC_PONG = 4;
     */
    SyncOp[SyncOp["SYNC_PONG"] = 4] = "SYNC_PONG";
})(SyncOp || (SyncOp = {}));
// Retrieve enum metadata with: proto3.getEnumType(SyncOp)
proto3.util.setEnumType(SyncOp, "river.SyncOp", [
    { no: 0, name: "SYNC_UNSPECIFIED" },
    { no: 1, name: "SYNC_NEW" },
    { no: 2, name: "SYNC_CLOSE" },
    { no: 3, name: "SYNC_UPDATE" },
    { no: 4, name: "SYNC_PONG" },
]);
/**
 * @generated from enum river.MembershipOp
 */
export var MembershipOp;
(function (MembershipOp) {
    /**
     * @generated from enum value: SO_UNSPECIFIED = 0;
     */
    MembershipOp[MembershipOp["SO_UNSPECIFIED"] = 0] = "SO_UNSPECIFIED";
    /**
     * @generated from enum value: SO_INVITE = 1;
     */
    MembershipOp[MembershipOp["SO_INVITE"] = 1] = "SO_INVITE";
    /**
     * @generated from enum value: SO_JOIN = 2;
     */
    MembershipOp[MembershipOp["SO_JOIN"] = 2] = "SO_JOIN";
    /**
     * @generated from enum value: SO_LEAVE = 3;
     */
    MembershipOp[MembershipOp["SO_LEAVE"] = 3] = "SO_LEAVE";
})(MembershipOp || (MembershipOp = {}));
// Retrieve enum metadata with: proto3.getEnumType(MembershipOp)
proto3.util.setEnumType(MembershipOp, "river.MembershipOp", [
    { no: 0, name: "SO_UNSPECIFIED" },
    { no: 1, name: "SO_INVITE" },
    { no: 2, name: "SO_JOIN" },
    { no: 3, name: "SO_LEAVE" },
]);
/**
 * @generated from enum river.ChannelOp
 */
export var ChannelOp;
(function (ChannelOp) {
    /**
     * @generated from enum value: CO_UNSPECIFIED = 0;
     */
    ChannelOp[ChannelOp["CO_UNSPECIFIED"] = 0] = "CO_UNSPECIFIED";
    /**
     * @generated from enum value: CO_CREATED = 1;
     */
    ChannelOp[ChannelOp["CO_CREATED"] = 1] = "CO_CREATED";
    /**
     * @generated from enum value: CO_DELETED = 2;
     */
    ChannelOp[ChannelOp["CO_DELETED"] = 2] = "CO_DELETED";
    /**
     * @generated from enum value: CO_UPDATED = 4;
     */
    ChannelOp[ChannelOp["CO_UPDATED"] = 4] = "CO_UPDATED";
})(ChannelOp || (ChannelOp = {}));
// Retrieve enum metadata with: proto3.getEnumType(ChannelOp)
proto3.util.setEnumType(ChannelOp, "river.ChannelOp", [
    { no: 0, name: "CO_UNSPECIFIED" },
    { no: 1, name: "CO_CREATED" },
    { no: 2, name: "CO_DELETED" },
    { no: 4, name: "CO_UPDATED" },
]);
/**
 * Codes from 1 to 16 match gRPC/Connect codes.
 *
 * @generated from enum river.Err
 */
export var Err;
(function (Err) {
    /**
     * @generated from enum value: ERR_UNSPECIFIED = 0;
     */
    Err[Err["ERR_UNSPECIFIED"] = 0] = "ERR_UNSPECIFIED";
    /**
     * Canceled indicates that the operation was canceled, typically by the
     * caller.
     *
     * @generated from enum value: CANCELED = 1;
     */
    Err[Err["CANCELED"] = 1] = "CANCELED";
    /**
     * Unknown indicates that the operation failed for an unknown reason.
     *
     * @generated from enum value: UNKNOWN = 2;
     */
    Err[Err["UNKNOWN"] = 2] = "UNKNOWN";
    /**
     * InvalidArgument indicates that client supplied an invalid argument.
     *
     * @generated from enum value: INVALID_ARGUMENT = 3;
     */
    Err[Err["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
    /**
     * DeadlineExceeded indicates that deadline expired before the operation
     * could complete.
     *
     * @generated from enum value: DEADLINE_EXCEEDED = 4;
     */
    Err[Err["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
    /**
     * NotFound indicates that some requested entity (for example, a file or
     * directory) was not found.
     *
     * @generated from enum value: NOT_FOUND = 5;
     */
    Err[Err["NOT_FOUND"] = 5] = "NOT_FOUND";
    /**
     * AlreadyExists indicates that client attempted to create an entity (for
     * example, a file or directory) that already exists.
     *
     * @generated from enum value: ALREADY_EXISTS = 6;
     */
    Err[Err["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
    /**
     * PermissionDenied indicates that the caller doesn't have permission to
     * execute the specified operation.
     *
     * @generated from enum value: PERMISSION_DENIED = 7;
     */
    Err[Err["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
    /**
     * ResourceExhausted indicates that some resource has been exhausted. For
     * example, a per-user quota may be exhausted or the entire file system may
     * be full.
     *
     * @generated from enum value: RESOURCE_EXHAUSTED = 8;
     */
    Err[Err["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
    /**
     * FailedPrecondition indicates that the system is not in a state
     * required for the operation's execution.
     *
     * @generated from enum value: FAILED_PRECONDITION = 9;
     */
    Err[Err["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
    /**
     * Aborted indicates that operation was aborted by the system, usually
     * because of a concurrency issue such as a sequencer check failure or
     * transaction abort.
     *
     * @generated from enum value: ABORTED = 10;
     */
    Err[Err["ABORTED"] = 10] = "ABORTED";
    /**
     * OutOfRange indicates that the operation was attempted past the valid
     * range (for example, seeking past end-of-file).
     *
     * @generated from enum value: OUT_OF_RANGE = 11;
     */
    Err[Err["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
    /**
     * Unimplemented indicates that the operation isn't implemented,
     * supported, or enabled in this service.
     *
     * @generated from enum value: UNIMPLEMENTED = 12;
     */
    Err[Err["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
    /**
     * Internal indicates that some invariants expected by the underlying
     * system have been broken. This code is reserved for serious errors.
     *
     * @generated from enum value: INTERNAL = 13;
     */
    Err[Err["INTERNAL"] = 13] = "INTERNAL";
    /**
     * Unavailable indicates that the service is currently unavailable. This
     * is usually temporary, so clients can back off and retry idempotent
     * operations.
     *
     * @generated from enum value: UNAVAILABLE = 14;
     */
    Err[Err["UNAVAILABLE"] = 14] = "UNAVAILABLE";
    /**
     * DataLoss indicates that the operation has resulted in unrecoverable
     * data loss or corruption.
     *
     * @generated from enum value: DATA_LOSS = 15;
     */
    Err[Err["DATA_LOSS"] = 15] = "DATA_LOSS";
    /**
     * Unauthenticated indicates that the request does not have valid
     * authentication credentials for the operation.
     *
     * @generated from enum value: UNAUTHENTICATED = 16;
     */
    Err[Err["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
    /**
     * @generated from enum value: DEBUG_ERROR = 17;
     */
    Err[Err["DEBUG_ERROR"] = 17] = "DEBUG_ERROR";
    /**
     * @generated from enum value: BAD_STREAM_ID = 18;
     */
    Err[Err["BAD_STREAM_ID"] = 18] = "BAD_STREAM_ID";
    /**
     * @generated from enum value: BAD_STREAM_CREATION_PARAMS = 19;
     */
    Err[Err["BAD_STREAM_CREATION_PARAMS"] = 19] = "BAD_STREAM_CREATION_PARAMS";
    /**
     * @generated from enum value: INTERNAL_ERROR_SWITCH = 20;
     */
    Err[Err["INTERNAL_ERROR_SWITCH"] = 20] = "INTERNAL_ERROR_SWITCH";
    /**
     * @generated from enum value: BAD_EVENT_ID = 21;
     */
    Err[Err["BAD_EVENT_ID"] = 21] = "BAD_EVENT_ID";
    /**
     * @generated from enum value: BAD_EVENT_SIGNATURE = 22;
     */
    Err[Err["BAD_EVENT_SIGNATURE"] = 22] = "BAD_EVENT_SIGNATURE";
    /**
     * @generated from enum value: BAD_HASH_FORMAT = 23;
     */
    Err[Err["BAD_HASH_FORMAT"] = 23] = "BAD_HASH_FORMAT";
    /**
     * @generated from enum value: BAD_PREV_MINIBLOCK_HASH = 24;
     */
    Err[Err["BAD_PREV_MINIBLOCK_HASH"] = 24] = "BAD_PREV_MINIBLOCK_HASH";
    /**
     * @generated from enum value: NO_EVENT_SPECIFIED = 25;
     */
    Err[Err["NO_EVENT_SPECIFIED"] = 25] = "NO_EVENT_SPECIFIED";
    /**
     * @generated from enum value: BAD_EVENT = 26;
     */
    Err[Err["BAD_EVENT"] = 26] = "BAD_EVENT";
    /**
     * @generated from enum value: USER_CANT_POST = 27;
     */
    Err[Err["USER_CANT_POST"] = 27] = "USER_CANT_POST";
    /**
     * @generated from enum value: STREAM_BAD_HASHES = 28;
     */
    Err[Err["STREAM_BAD_HASHES"] = 28] = "STREAM_BAD_HASHES";
    /**
     * @generated from enum value: STREAM_EMPTY = 29;
     */
    Err[Err["STREAM_EMPTY"] = 29] = "STREAM_EMPTY";
    /**
     * @generated from enum value: STREAM_BAD_EVENT = 30;
     */
    Err[Err["STREAM_BAD_EVENT"] = 30] = "STREAM_BAD_EVENT";
    /**
     * @generated from enum value: BAD_DELEGATE_SIG = 31;
     */
    Err[Err["BAD_DELEGATE_SIG"] = 31] = "BAD_DELEGATE_SIG";
    /**
     * @generated from enum value: BAD_PUBLIC_KEY = 32;
     */
    Err[Err["BAD_PUBLIC_KEY"] = 32] = "BAD_PUBLIC_KEY";
    /**
     * @generated from enum value: BAD_PAYLOAD = 33;
     */
    Err[Err["BAD_PAYLOAD"] = 33] = "BAD_PAYLOAD";
    /**
     * @generated from enum value: BAD_HEX_STRING = 34;
     */
    Err[Err["BAD_HEX_STRING"] = 34] = "BAD_HEX_STRING";
    /**
     * @generated from enum value: BAD_EVENT_HASH = 35;
     */
    Err[Err["BAD_EVENT_HASH"] = 35] = "BAD_EVENT_HASH";
    /**
     * @generated from enum value: BAD_SYNC_COOKIE = 36;
     */
    Err[Err["BAD_SYNC_COOKIE"] = 36] = "BAD_SYNC_COOKIE";
    /**
     * @generated from enum value: DUPLICATE_EVENT = 37;
     */
    Err[Err["DUPLICATE_EVENT"] = 37] = "DUPLICATE_EVENT";
    /**
     * @generated from enum value: BAD_BLOCK = 38;
     */
    Err[Err["BAD_BLOCK"] = 38] = "BAD_BLOCK";
    /**
     * @generated from enum value: STREAM_NO_INCEPTION_EVENT = 39;
     */
    Err[Err["STREAM_NO_INCEPTION_EVENT"] = 39] = "STREAM_NO_INCEPTION_EVENT";
    /**
     * @generated from enum value: BAD_BLOCK_NUMBER = 40;
     */
    Err[Err["BAD_BLOCK_NUMBER"] = 40] = "BAD_BLOCK_NUMBER";
    /**
     * @generated from enum value: BAD_MINIPOOL_SLOT = 41;
     */
    Err[Err["BAD_MINIPOOL_SLOT"] = 41] = "BAD_MINIPOOL_SLOT";
    /**
     * @generated from enum value: BAD_CREATOR_ADDRESS = 42;
     */
    Err[Err["BAD_CREATOR_ADDRESS"] = 42] = "BAD_CREATOR_ADDRESS";
    /**
     * @generated from enum value: STALE_DELEGATE = 43;
     */
    Err[Err["STALE_DELEGATE"] = 43] = "STALE_DELEGATE";
    /**
     * @generated from enum value: BAD_LINK_WALLET_BAD_SIGNATURE = 44;
     */
    Err[Err["BAD_LINK_WALLET_BAD_SIGNATURE"] = 44] = "BAD_LINK_WALLET_BAD_SIGNATURE";
    /**
     * @generated from enum value: BAD_ROOT_KEY_ID = 45;
     */
    Err[Err["BAD_ROOT_KEY_ID"] = 45] = "BAD_ROOT_KEY_ID";
    /**
     * @generated from enum value: UNKNOWN_NODE = 46;
     */
    Err[Err["UNKNOWN_NODE"] = 46] = "UNKNOWN_NODE";
    /**
     * @generated from enum value: DB_OPERATION_FAILURE = 47;
     */
    Err[Err["DB_OPERATION_FAILURE"] = 47] = "DB_OPERATION_FAILURE";
    /**
     * @generated from enum value: MINIBLOCKS_STORAGE_FAILURE = 48;
     */
    Err[Err["MINIBLOCKS_STORAGE_FAILURE"] = 48] = "MINIBLOCKS_STORAGE_FAILURE";
    /**
     * @generated from enum value: BAD_ADDRESS = 49;
     */
    Err[Err["BAD_ADDRESS"] = 49] = "BAD_ADDRESS";
    /**
     * @generated from enum value: BUFFER_FULL = 50;
     */
    Err[Err["BUFFER_FULL"] = 50] = "BUFFER_FULL";
    /**
     * @generated from enum value: BAD_CONFIG = 51;
     */
    Err[Err["BAD_CONFIG"] = 51] = "BAD_CONFIG";
    /**
     * @generated from enum value: BAD_CONTRACT = 52;
     */
    Err[Err["BAD_CONTRACT"] = 52] = "BAD_CONTRACT";
    /**
     * @generated from enum value: CANNOT_CONNECT = 53;
     */
    Err[Err["CANNOT_CONNECT"] = 53] = "CANNOT_CONNECT";
    /**
     * @generated from enum value: CANNOT_GET_LINKED_WALLETS = 54;
     */
    Err[Err["CANNOT_GET_LINKED_WALLETS"] = 54] = "CANNOT_GET_LINKED_WALLETS";
    /**
     * @generated from enum value: CANNOT_CHECK_ENTITLEMENTS = 55;
     */
    Err[Err["CANNOT_CHECK_ENTITLEMENTS"] = 55] = "CANNOT_CHECK_ENTITLEMENTS";
    /**
     * @generated from enum value: CANNOT_CALL_CONTRACT = 56;
     */
    Err[Err["CANNOT_CALL_CONTRACT"] = 56] = "CANNOT_CALL_CONTRACT";
    /**
     * @generated from enum value: SPACE_DISABLED = 57;
     */
    Err[Err["SPACE_DISABLED"] = 57] = "SPACE_DISABLED";
    /**
     * @generated from enum value: CHANNEL_DISABLED = 58;
     */
    Err[Err["CHANNEL_DISABLED"] = 58] = "CHANNEL_DISABLED";
    /**
     * @generated from enum value: WRONG_STREAM_TYPE = 59;
     */
    Err[Err["WRONG_STREAM_TYPE"] = 59] = "WRONG_STREAM_TYPE";
    /**
     * @generated from enum value: MINIPOOL_MISSING_EVENTS = 60;
     */
    Err[Err["MINIPOOL_MISSING_EVENTS"] = 60] = "MINIPOOL_MISSING_EVENTS";
    /**
     * @generated from enum value: STREAM_LAST_BLOCK_MISMATCH = 61;
     */
    Err[Err["STREAM_LAST_BLOCK_MISMATCH"] = 61] = "STREAM_LAST_BLOCK_MISMATCH";
    /**
     * @generated from enum value: DOWNSTREAM_NETWORK_ERROR = 62;
     */
    Err[Err["DOWNSTREAM_NETWORK_ERROR"] = 62] = "DOWNSTREAM_NETWORK_ERROR";
})(Err || (Err = {}));
// Retrieve enum metadata with: proto3.getEnumType(Err)
proto3.util.setEnumType(Err, "river.Err", [
    { no: 0, name: "ERR_UNSPECIFIED" },
    { no: 1, name: "CANCELED" },
    { no: 2, name: "UNKNOWN" },
    { no: 3, name: "INVALID_ARGUMENT" },
    { no: 4, name: "DEADLINE_EXCEEDED" },
    { no: 5, name: "NOT_FOUND" },
    { no: 6, name: "ALREADY_EXISTS" },
    { no: 7, name: "PERMISSION_DENIED" },
    { no: 8, name: "RESOURCE_EXHAUSTED" },
    { no: 9, name: "FAILED_PRECONDITION" },
    { no: 10, name: "ABORTED" },
    { no: 11, name: "OUT_OF_RANGE" },
    { no: 12, name: "UNIMPLEMENTED" },
    { no: 13, name: "INTERNAL" },
    { no: 14, name: "UNAVAILABLE" },
    { no: 15, name: "DATA_LOSS" },
    { no: 16, name: "UNAUTHENTICATED" },
    { no: 17, name: "DEBUG_ERROR" },
    { no: 18, name: "BAD_STREAM_ID" },
    { no: 19, name: "BAD_STREAM_CREATION_PARAMS" },
    { no: 20, name: "INTERNAL_ERROR_SWITCH" },
    { no: 21, name: "BAD_EVENT_ID" },
    { no: 22, name: "BAD_EVENT_SIGNATURE" },
    { no: 23, name: "BAD_HASH_FORMAT" },
    { no: 24, name: "BAD_PREV_MINIBLOCK_HASH" },
    { no: 25, name: "NO_EVENT_SPECIFIED" },
    { no: 26, name: "BAD_EVENT" },
    { no: 27, name: "USER_CANT_POST" },
    { no: 28, name: "STREAM_BAD_HASHES" },
    { no: 29, name: "STREAM_EMPTY" },
    { no: 30, name: "STREAM_BAD_EVENT" },
    { no: 31, name: "BAD_DELEGATE_SIG" },
    { no: 32, name: "BAD_PUBLIC_KEY" },
    { no: 33, name: "BAD_PAYLOAD" },
    { no: 34, name: "BAD_HEX_STRING" },
    { no: 35, name: "BAD_EVENT_HASH" },
    { no: 36, name: "BAD_SYNC_COOKIE" },
    { no: 37, name: "DUPLICATE_EVENT" },
    { no: 38, name: "BAD_BLOCK" },
    { no: 39, name: "STREAM_NO_INCEPTION_EVENT" },
    { no: 40, name: "BAD_BLOCK_NUMBER" },
    { no: 41, name: "BAD_MINIPOOL_SLOT" },
    { no: 42, name: "BAD_CREATOR_ADDRESS" },
    { no: 43, name: "STALE_DELEGATE" },
    { no: 44, name: "BAD_LINK_WALLET_BAD_SIGNATURE" },
    { no: 45, name: "BAD_ROOT_KEY_ID" },
    { no: 46, name: "UNKNOWN_NODE" },
    { no: 47, name: "DB_OPERATION_FAILURE" },
    { no: 48, name: "MINIBLOCKS_STORAGE_FAILURE" },
    { no: 49, name: "BAD_ADDRESS" },
    { no: 50, name: "BUFFER_FULL" },
    { no: 51, name: "BAD_CONFIG" },
    { no: 52, name: "BAD_CONTRACT" },
    { no: 53, name: "CANNOT_CONNECT" },
    { no: 54, name: "CANNOT_GET_LINKED_WALLETS" },
    { no: 55, name: "CANNOT_CHECK_ENTITLEMENTS" },
    { no: 56, name: "CANNOT_CALL_CONTRACT" },
    { no: 57, name: "SPACE_DISABLED" },
    { no: 58, name: "CHANNEL_DISABLED" },
    { no: 59, name: "WRONG_STREAM_TYPE" },
    { no: 60, name: "MINIPOOL_MISSING_EVENTS" },
    { no: 61, name: "STREAM_LAST_BLOCK_MISMATCH" },
    { no: 62, name: "DOWNSTREAM_NETWORK_ERROR" },
]);
/**
 * *
 * Miniblock contains a list of events and the header event.
 * Events must be in the same order as in the header, which is of type MiniblockHeader.
 * Only signed data (Envelopes) should exist in this data structure.
 *
 * @generated from message river.Miniblock
 */
export class Miniblock extends Message {
    /**
     * @generated from field: repeated river.Envelope events = 1;
     */
    events = [];
    /**
     * @generated from field: river.Envelope header = 2;
     */
    header;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.Miniblock";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "events", kind: "message", T: Envelope, repeated: true },
        { no: 2, name: "header", kind: "message", T: Envelope },
    ]);
    static fromBinary(bytes, options) {
        return new Miniblock().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Miniblock().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Miniblock().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Miniblock, a, b);
    }
}
/**
 * *
 * Envelope contains serialized event, and its hash and signature.
 * hash is used as event id. Subsequent events reference this event by hash.
 * event is a serialized StreamEvent
 *
 * @generated from message river.Envelope
 */
export class Envelope extends Message {
    /**
     * *
     * Hash of event.
     * While hash can be recalculated from the event, having it here explicitely
     * makes it easier to work with event.
     * For the event to be valid, must match hash of event field.
     *
     * @generated from field: bytes hash = 1;
     */
    hash = new Uint8Array(0);
    /**
     * *
     * Signature.
     * For the event to be valid, signature must match event.creator_address
     * or be signed by the address from evant.delegate_sig.
     *
     * @generated from field: bytes signature = 2;
     */
    signature = new Uint8Array(0);
    /**
     * @generated from field: bytes event = 3;
     */
    event = new Uint8Array(0);
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.Envelope";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "signature", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 3, name: "event", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    ]);
    static fromBinary(bytes, options) {
        return new Envelope().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Envelope().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Envelope().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Envelope, a, b);
    }
}
/**
 * *
 * StreamEvent is a single event in the stream.
 *
 * @generated from message river.StreamEvent
 */
export class StreamEvent extends Message {
    /**
     * *
     * Address of the creator of the event.
     * For user - address of the user's wallet.
     * For server - address of the server's keypair in staking smart contract.
     *
     * For the event to be valid:
     * If delegate_sig is present, creator_address must match delegate_sig.
     * If delegate_sig is not present, creator_address must match event signature in the Envelope.
     *
     * @generated from field: bytes creator_address = 1;
     */
    creatorAddress = new Uint8Array(0);
    /**
     * *
     * delegate_sig allows event to be signed by a delegate keypair
     *
     * delegate_sig constains signature of the
     * public key of the delegate keypair + the delegate_expirary_epoch_ms.
     * User's wallet is used to produce this signature.
     *
     * If present, for the event to be valid:
     * 1. creator_address must match delegate_sig's signer public key
     * 2. delegate_sig should be signed as an Ethereum Signed Message (eip-191)
     *
     * Server nodes sign node-produced events with their own keypair and do not
     * need to use delegate_sig.
     *
     * @generated from field: bytes delegate_sig = 2;
     */
    delegateSig = new Uint8Array(0);
    /**
     * * Salt ensures that similar messages are not hashed to the same value. genId() from id.ts may be used.
     *
     * @generated from field: bytes salt = 3;
     */
    salt = new Uint8Array(0);
    /**
     * * Hash of a preceding miniblock. Null for the inception event. Must be a recent miniblock
     *
     * @generated from field: optional bytes prev_miniblock_hash = 4;
     */
    prevMiniblockHash;
    /**
     * * CreatedAt is the time when the event was created.
     * NOTE: this value is set by clients and is not reliable for anything other than displaying
     * the value to the user. Never use this value to sort events from different users.
     *
     * @generated from field: int64 created_at_epoch_ms = 5;
     */
    createdAtEpochMs = protoInt64.zero;
    /**
     * * DelegateExpiry is the time when the delegate signature expires.
     *
     * @generated from field: int64 delegate_expiry_epoch_ms = 6;
     */
    delegateExpiryEpochMs = protoInt64.zero;
    /**
     * * Variable-type payload.
     * Payloads should obey the following rules:
     * - payloads should have their own unique type
     * - each payload should have a oneof content field
     * - each payload, with the exception of miniblock header and member payloads
     *     should have an inception field inside the content oneof
     * - each payload should have a unique Inception type
     * - payloads can't violate previous type recursively to inception payload
     *
     * @generated from oneof river.StreamEvent.payload
     */
    payload = { case: undefined };
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.StreamEvent";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "creator_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "delegate_sig", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 3, name: "salt", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 4, name: "prev_miniblock_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
        { no: 5, name: "created_at_epoch_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
        { no: 6, name: "delegate_expiry_epoch_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
        { no: 100, name: "miniblock_header", kind: "message", T: MiniblockHeader, oneof: "payload" },
        { no: 101, name: "member_payload", kind: "message", T: MemberPayload, oneof: "payload" },
        { no: 102, name: "space_payload", kind: "message", T: SpacePayload, oneof: "payload" },
        { no: 103, name: "channel_payload", kind: "message", T: ChannelPayload, oneof: "payload" },
        { no: 104, name: "user_payload", kind: "message", T: UserPayload, oneof: "payload" },
        { no: 105, name: "user_settings_payload", kind: "message", T: UserSettingsPayload, oneof: "payload" },
        { no: 106, name: "user_device_key_payload", kind: "message", T: UserDeviceKeyPayload, oneof: "payload" },
        { no: 107, name: "user_inbox_payload", kind: "message", T: UserInboxPayload, oneof: "payload" },
        { no: 108, name: "media_payload", kind: "message", T: MediaPayload, oneof: "payload" },
        { no: 109, name: "dm_channel_payload", kind: "message", T: DmChannelPayload, oneof: "payload" },
        { no: 110, name: "gdm_channel_payload", kind: "message", T: GdmChannelPayload, oneof: "payload" },
    ]);
    static fromBinary(bytes, options) {
        return new StreamEvent().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new StreamEvent().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new StreamEvent().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(StreamEvent, a, b);
    }
}
/**
 * *
 * MiniblockHeader is a special event that forms a block from set of the stream events.
 * Hash of the serialized StreamEvent containing MiniblockHeader is used as a block hash.
 *
 * @generated from message river.MiniblockHeader
 */
export class MiniblockHeader extends Message {
    /**
     * Miniblock number.
     * 0 for genesis block.
     * Must be 1 greater than the previous block number.
     *
     * @generated from field: int64 miniblock_num = 1;
     */
    miniblockNum = protoInt64.zero;
    /**
     * Hash of the previous block.
     *
     * @generated from field: bytes prev_miniblock_hash = 2;
     */
    prevMiniblockHash = new Uint8Array(0);
    /**
     * Timestamp of the block.
     * Must be greater than the previous block timestamp.
     *
     * @generated from field: google.protobuf.Timestamp timestamp = 3;
     */
    timestamp;
    /**
     * Hashes of the events included in the block.
     *
     * @generated from field: repeated bytes event_hashes = 4;
     */
    eventHashes = [];
    /**
     * Snapshot of the state at the end of the block.
     *
     * @generated from field: optional river.Snapshot snapshot = 5;
     */
    snapshot;
    /**
     * count of all events in the stream before this block
     *
     * @generated from field: int64 event_num_offset = 6;
     */
    eventNumOffset = protoInt64.zero;
    /**
     * pointer to block with previous snapshot
     *
     * @generated from field: int64 prev_snapshot_miniblock_num = 7;
     */
    prevSnapshotMiniblockNum = protoInt64.zero;
    /**
     * stream payloads are required to have a content field
     *
     * @generated from oneof river.MiniblockHeader.content
     */
    content = { case: undefined };
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.MiniblockHeader";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "miniblock_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
        { no: 2, name: "prev_miniblock_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 3, name: "timestamp", kind: "message", T: Timestamp },
        { no: 4, name: "event_hashes", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
        { no: 5, name: "snapshot", kind: "message", T: Snapshot, opt: true },
        { no: 6, name: "event_num_offset", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
        { no: 7, name: "prev_snapshot_miniblock_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
        { no: 100, name: "none", kind: "message", T: Empty, oneof: "content" },
    ]);
    static fromBinary(bytes, options) {
        return new MiniblockHeader().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MiniblockHeader().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MiniblockHeader().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MiniblockHeader, a, b);
    }
}
/**
 * *
 * MemberPayload
 * can appear in any stream
 *
 * @generated from message river.MemberPayload
 */
export class MemberPayload extends Message {
    /**
     * @generated from oneof river.MemberPayload.content
     */
    content = { case: undefined };
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.MemberPayload";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "membership", kind: "message", T: MemberPayload_Membership, oneof: "content" },
        { no: 2, name: "key_solicitation", kind: "message", T: MemberPayload_KeySolicitation, oneof: "content" },
        { no: 3, name: "key_fulfillment", kind: "message", T: MemberPayload_KeyFulfillment, oneof: "content" },
        { no: 4, name: "username", kind: "message", T: EncryptedData, oneof: "content" },
        { no: 5, name: "display_name", kind: "message", T: EncryptedData, oneof: "content" },
        { no: 6, name: "ens_address", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "content" },
        { no: 7, name: "nft", kind: "message", T: MemberPayload_Nft, oneof: "content" },
    ]);
    static fromBinary(bytes, options) {
        return new MemberPayload().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MemberPayload().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MemberPayload().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MemberPayload, a, b);
    }
}
/**
 * @generated from message river.MemberPayload.Snapshot
 */
export class MemberPayload_Snapshot extends Message {
    /**
     * @generated from field: repeated river.MemberPayload.Snapshot.Member joined = 1;
     */
    joined = [];
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.MemberPayload.Snapshot";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "joined", kind: "message", T: MemberPayload_Snapshot_Member, repeated: true },
    ]);
    static fromBinary(bytes, options) {
        return new MemberPayload_Snapshot().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MemberPayload_Snapshot().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MemberPayload_Snapshot().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MemberPayload_Snapshot, a, b);
    }
}
/**
 * @generated from message river.MemberPayload.Snapshot.Member
 */
export class MemberPayload_Snapshot_Member extends Message {
    /**
     * @generated from field: bytes user_address = 1;
     */
    userAddress = new Uint8Array(0);
    /**
     * @generated from field: int64 miniblock_num = 2;
     */
    miniblockNum = protoInt64.zero;
    /**
     * @generated from field: int64 event_num = 3;
     */
    eventNum = protoInt64.zero;
    /**
     * @generated from field: repeated river.MemberPayload.KeySolicitation solicitations = 4;
     */
    solicitations = [];
    /**
     * @generated from field: river.WrappedEncryptedData username = 5;
     */
    username;
    /**
     * @generated from field: river.WrappedEncryptedData display_name = 6;
     */
    displayName;
    /**
     * @generated from field: bytes ens_address = 7;
     */
    ensAddress = new Uint8Array(0);
    /**
     * @generated from field: river.MemberPayload.Nft nft = 8;
     */
    nft;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.MemberPayload.Snapshot.Member";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "user_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "miniblock_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
        { no: 3, name: "event_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
        { no: 4, name: "solicitations", kind: "message", T: MemberPayload_KeySolicitation, repeated: true },
        { no: 5, name: "username", kind: "message", T: WrappedEncryptedData },
        { no: 6, name: "display_name", kind: "message", T: WrappedEncryptedData },
        { no: 7, name: "ens_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 8, name: "nft", kind: "message", T: MemberPayload_Nft },
    ]);
    static fromBinary(bytes, options) {
        return new MemberPayload_Snapshot_Member().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MemberPayload_Snapshot_Member().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MemberPayload_Snapshot_Member().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MemberPayload_Snapshot_Member, a, b);
    }
}
/**
 * @generated from message river.MemberPayload.Membership
 */
export class MemberPayload_Membership extends Message {
    /**
     * @generated from field: river.MembershipOp op = 1;
     */
    op = MembershipOp.SO_UNSPECIFIED;
    /**
     * @generated from field: bytes user_address = 2;
     */
    userAddress = new Uint8Array(0);
    /**
     * @generated from field: bytes initiator_address = 3;
     */
    initiatorAddress = new Uint8Array(0);
    /**
     * @generated from field: optional bytes stream_parent_id = 4;
     */
    streamParentId;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.MemberPayload.Membership";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "op", kind: "enum", T: proto3.getEnumType(MembershipOp) },
        { no: 2, name: "user_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 3, name: "initiator_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 4, name: "stream_parent_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    ]);
    static fromBinary(bytes, options) {
        return new MemberPayload_Membership().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MemberPayload_Membership().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MemberPayload_Membership().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MemberPayload_Membership, a, b);
    }
}
/**
 * @generated from message river.MemberPayload.KeySolicitation
 */
export class MemberPayload_KeySolicitation extends Message {
    /**
     * requesters device_key
     *
     * @generated from field: string device_key = 1;
     */
    deviceKey = "";
    /**
     * requesters fallback_key
     *
     * @generated from field: string fallback_key = 2;
     */
    fallbackKey = "";
    /**
     * true if this is a new device, session_ids will be empty
     *
     * @generated from field: bool is_new_device = 3;
     */
    isNewDevice = false;
    /**
     * @generated from field: repeated string session_ids = 4;
     */
    sessionIds = [];
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.MemberPayload.KeySolicitation";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "device_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "fallback_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 3, name: "is_new_device", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
        { no: 4, name: "session_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    ]);
    static fromBinary(bytes, options) {
        return new MemberPayload_KeySolicitation().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MemberPayload_KeySolicitation().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MemberPayload_KeySolicitation().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MemberPayload_KeySolicitation, a, b);
    }
}
/**
 * @generated from message river.MemberPayload.KeyFulfillment
 */
export class MemberPayload_KeyFulfillment extends Message {
    /**
     * @generated from field: bytes user_address = 1;
     */
    userAddress = new Uint8Array(0);
    /**
     * @generated from field: string device_key = 2;
     */
    deviceKey = "";
    /**
     * @generated from field: repeated string session_ids = 3;
     */
    sessionIds = [];
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.MemberPayload.KeyFulfillment";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "user_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "device_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 3, name: "session_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    ]);
    static fromBinary(bytes, options) {
        return new MemberPayload_KeyFulfillment().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MemberPayload_KeyFulfillment().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MemberPayload_KeyFulfillment().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MemberPayload_KeyFulfillment, a, b);
    }
}
/**
 * @generated from message river.MemberPayload.Nft
 */
export class MemberPayload_Nft extends Message {
    /**
     * @generated from field: int32 chain_id = 1;
     */
    chainId = 0;
    /**
     * @generated from field: bytes contract_address = 2;
     */
    contractAddress = new Uint8Array(0);
    /**
     * @generated from field: bytes token_id = 3;
     */
    tokenId = new Uint8Array(0);
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.MemberPayload.Nft";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "chain_id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
        { no: 2, name: "contract_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 3, name: "token_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    ]);
    static fromBinary(bytes, options) {
        return new MemberPayload_Nft().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MemberPayload_Nft().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MemberPayload_Nft().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MemberPayload_Nft, a, b);
    }
}
/**
 * *
 * SpacePayload
 *
 * @generated from message river.SpacePayload
 */
export class SpacePayload extends Message {
    /**
     * @generated from oneof river.SpacePayload.content
     */
    content = { case: undefined };
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.SpacePayload";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: SpacePayload_Inception, oneof: "content" },
        { no: 2, name: "channel", kind: "message", T: SpacePayload_ChannelUpdate, oneof: "content" },
    ]);
    static fromBinary(bytes, options) {
        return new SpacePayload().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SpacePayload().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SpacePayload().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SpacePayload, a, b);
    }
}
/**
 * @generated from message river.SpacePayload.Snapshot
 */
export class SpacePayload_Snapshot extends Message {
    /**
     * inception
     *
     * @generated from field: river.SpacePayload.Inception inception = 1;
     */
    inception;
    /**
     * channels: sorted by channel_id
     *
     * @generated from field: repeated river.SpacePayload.ChannelMetadata channels = 2;
     */
    channels = [];
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.SpacePayload.Snapshot";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: SpacePayload_Inception },
        { no: 2, name: "channels", kind: "message", T: SpacePayload_ChannelMetadata, repeated: true },
    ]);
    static fromBinary(bytes, options) {
        return new SpacePayload_Snapshot().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SpacePayload_Snapshot().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SpacePayload_Snapshot().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SpacePayload_Snapshot, a, b);
    }
}
/**
 * @generated from message river.SpacePayload.Inception
 */
export class SpacePayload_Inception extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: river.StreamSettings settings = 2;
     */
    settings;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.SpacePayload.Inception";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "settings", kind: "message", T: StreamSettings },
    ]);
    static fromBinary(bytes, options) {
        return new SpacePayload_Inception().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SpacePayload_Inception().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SpacePayload_Inception().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SpacePayload_Inception, a, b);
    }
}
/**
 * @generated from message river.SpacePayload.ChannelMetadata
 */
export class SpacePayload_ChannelMetadata extends Message {
    /**
     * @generated from field: river.ChannelOp op = 1;
     */
    op = ChannelOp.CO_UNSPECIFIED;
    /**
     * @generated from field: bytes channel_id = 2;
     */
    channelId = new Uint8Array(0);
    /**
     * @generated from field: river.EventRef origin_event = 3;
     */
    originEvent;
    /**
     * @generated from field: int64 updated_at_event_num = 6;
     */
    updatedAtEventNum = protoInt64.zero;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.SpacePayload.ChannelMetadata";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "op", kind: "enum", T: proto3.getEnumType(ChannelOp) },
        { no: 2, name: "channel_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 3, name: "origin_event", kind: "message", T: EventRef },
        { no: 6, name: "updated_at_event_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    ]);
    static fromBinary(bytes, options) {
        return new SpacePayload_ChannelMetadata().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SpacePayload_ChannelMetadata().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SpacePayload_ChannelMetadata().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SpacePayload_ChannelMetadata, a, b);
    }
}
/**
 * @generated from message river.SpacePayload.ChannelUpdate
 */
export class SpacePayload_ChannelUpdate extends Message {
    /**
     * @generated from field: river.ChannelOp op = 1;
     */
    op = ChannelOp.CO_UNSPECIFIED;
    /**
     * @generated from field: bytes channel_id = 2;
     */
    channelId = new Uint8Array(0);
    /**
     * @generated from field: river.EventRef origin_event = 3;
     */
    originEvent;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.SpacePayload.ChannelUpdate";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "op", kind: "enum", T: proto3.getEnumType(ChannelOp) },
        { no: 2, name: "channel_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 3, name: "origin_event", kind: "message", T: EventRef },
    ]);
    static fromBinary(bytes, options) {
        return new SpacePayload_ChannelUpdate().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SpacePayload_ChannelUpdate().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SpacePayload_ChannelUpdate().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SpacePayload_ChannelUpdate, a, b);
    }
}
/**
 * *
 * ChannelPayload
 *
 * @generated from message river.ChannelPayload
 */
export class ChannelPayload extends Message {
    /**
     * @generated from oneof river.ChannelPayload.content
     */
    content = { case: undefined };
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.ChannelPayload";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: ChannelPayload_Inception, oneof: "content" },
        { no: 2, name: "message", kind: "message", T: EncryptedData, oneof: "content" },
        { no: 3, name: "redaction", kind: "message", T: ChannelPayload_Redaction, oneof: "content" },
    ]);
    static fromBinary(bytes, options) {
        return new ChannelPayload().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ChannelPayload().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ChannelPayload().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ChannelPayload, a, b);
    }
}
/**
 * @generated from message river.ChannelPayload.Snapshot
 */
export class ChannelPayload_Snapshot extends Message {
    /**
     * inception
     *
     * @generated from field: river.ChannelPayload.Inception inception = 1;
     */
    inception;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.ChannelPayload.Snapshot";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: ChannelPayload_Inception },
    ]);
    static fromBinary(bytes, options) {
        return new ChannelPayload_Snapshot().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ChannelPayload_Snapshot().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ChannelPayload_Snapshot().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ChannelPayload_Snapshot, a, b);
    }
}
/**
 * @generated from message river.ChannelPayload.Inception
 */
export class ChannelPayload_Inception extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: bytes space_id = 3;
     */
    spaceId = new Uint8Array(0);
    /**
     * @generated from field: river.StreamSettings settings = 5;
     */
    settings;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.ChannelPayload.Inception";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 3, name: "space_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 5, name: "settings", kind: "message", T: StreamSettings },
    ]);
    static fromBinary(bytes, options) {
        return new ChannelPayload_Inception().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ChannelPayload_Inception().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ChannelPayload_Inception().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ChannelPayload_Inception, a, b);
    }
}
/**
 * @generated from message river.ChannelPayload.Redaction
 */
export class ChannelPayload_Redaction extends Message {
    /**
     * @generated from field: bytes event_id = 1;
     */
    eventId = new Uint8Array(0);
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.ChannelPayload.Redaction";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "event_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    ]);
    static fromBinary(bytes, options) {
        return new ChannelPayload_Redaction().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ChannelPayload_Redaction().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ChannelPayload_Redaction().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(ChannelPayload_Redaction, a, b);
    }
}
/**
 * *
 * DmChannelPayload
 *
 * @generated from message river.DmChannelPayload
 */
export class DmChannelPayload extends Message {
    /**
     * @generated from oneof river.DmChannelPayload.content
     */
    content = { case: undefined };
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.DmChannelPayload";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: DmChannelPayload_Inception, oneof: "content" },
        { no: 3, name: "message", kind: "message", T: EncryptedData, oneof: "content" },
    ]);
    static fromBinary(bytes, options) {
        return new DmChannelPayload().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new DmChannelPayload().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new DmChannelPayload().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(DmChannelPayload, a, b);
    }
}
/**
 * @generated from message river.DmChannelPayload.Snapshot
 */
export class DmChannelPayload_Snapshot extends Message {
    /**
     * @generated from field: river.DmChannelPayload.Inception inception = 1;
     */
    inception;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.DmChannelPayload.Snapshot";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: DmChannelPayload_Inception },
    ]);
    static fromBinary(bytes, options) {
        return new DmChannelPayload_Snapshot().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new DmChannelPayload_Snapshot().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new DmChannelPayload_Snapshot().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(DmChannelPayload_Snapshot, a, b);
    }
}
/**
 * @generated from message river.DmChannelPayload.Inception
 */
export class DmChannelPayload_Inception extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: bytes first_party_address = 2;
     */
    firstPartyAddress = new Uint8Array(0);
    /**
     * @generated from field: bytes second_party_address = 3;
     */
    secondPartyAddress = new Uint8Array(0);
    /**
     * @generated from field: river.StreamSettings settings = 4;
     */
    settings;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.DmChannelPayload.Inception";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "first_party_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 3, name: "second_party_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 4, name: "settings", kind: "message", T: StreamSettings },
    ]);
    static fromBinary(bytes, options) {
        return new DmChannelPayload_Inception().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new DmChannelPayload_Inception().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new DmChannelPayload_Inception().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(DmChannelPayload_Inception, a, b);
    }
}
/**
 * *
 * GdmChannelPayload
 *
 * @generated from message river.GdmChannelPayload
 */
export class GdmChannelPayload extends Message {
    /**
     * @generated from oneof river.GdmChannelPayload.content
     */
    content = { case: undefined };
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.GdmChannelPayload";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: GdmChannelPayload_Inception, oneof: "content" },
        { no: 2, name: "message", kind: "message", T: EncryptedData, oneof: "content" },
        { no: 3, name: "channel_properties", kind: "message", T: EncryptedData, oneof: "content" },
    ]);
    static fromBinary(bytes, options) {
        return new GdmChannelPayload().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new GdmChannelPayload().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new GdmChannelPayload().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(GdmChannelPayload, a, b);
    }
}
/**
 * @generated from message river.GdmChannelPayload.Snapshot
 */
export class GdmChannelPayload_Snapshot extends Message {
    /**
     * @generated from field: river.GdmChannelPayload.Inception inception = 1;
     */
    inception;
    /**
     * @generated from field: river.WrappedEncryptedData channel_properties = 2;
     */
    channelProperties;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.GdmChannelPayload.Snapshot";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: GdmChannelPayload_Inception },
        { no: 2, name: "channel_properties", kind: "message", T: WrappedEncryptedData },
    ]);
    static fromBinary(bytes, options) {
        return new GdmChannelPayload_Snapshot().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new GdmChannelPayload_Snapshot().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new GdmChannelPayload_Snapshot().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(GdmChannelPayload_Snapshot, a, b);
    }
}
/**
 * @generated from message river.GdmChannelPayload.Inception
 */
export class GdmChannelPayload_Inception extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: river.EncryptedData channel_properties = 2;
     */
    channelProperties;
    /**
     * @generated from field: river.StreamSettings settings = 3;
     */
    settings;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.GdmChannelPayload.Inception";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "channel_properties", kind: "message", T: EncryptedData },
        { no: 3, name: "settings", kind: "message", T: StreamSettings },
    ]);
    static fromBinary(bytes, options) {
        return new GdmChannelPayload_Inception().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new GdmChannelPayload_Inception().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new GdmChannelPayload_Inception().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(GdmChannelPayload_Inception, a, b);
    }
}
/**
 * *
 * UserPayload
 *
 * @generated from message river.UserPayload
 */
export class UserPayload extends Message {
    /**
     * @generated from oneof river.UserPayload.content
     */
    content = { case: undefined };
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserPayload";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: UserPayload_Inception, oneof: "content" },
        { no: 2, name: "user_membership", kind: "message", T: UserPayload_UserMembership, oneof: "content" },
        { no: 3, name: "user_membership_action", kind: "message", T: UserPayload_UserMembershipAction, oneof: "content" },
    ]);
    static fromBinary(bytes, options) {
        return new UserPayload().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserPayload().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserPayload().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserPayload, a, b);
    }
}
/**
 * @generated from message river.UserPayload.Snapshot
 */
export class UserPayload_Snapshot extends Message {
    /**
     * inception
     *
     * @generated from field: river.UserPayload.Inception inception = 1;
     */
    inception;
    /**
     * memberships, sorted by stream_id
     *
     * @generated from field: repeated river.UserPayload.UserMembership memberships = 2;
     */
    memberships = [];
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserPayload.Snapshot";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: UserPayload_Inception },
        { no: 2, name: "memberships", kind: "message", T: UserPayload_UserMembership, repeated: true },
    ]);
    static fromBinary(bytes, options) {
        return new UserPayload_Snapshot().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserPayload_Snapshot().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserPayload_Snapshot().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserPayload_Snapshot, a, b);
    }
}
/**
 * @generated from message river.UserPayload.Inception
 */
export class UserPayload_Inception extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: river.StreamSettings settings = 2;
     */
    settings;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserPayload.Inception";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "settings", kind: "message", T: StreamSettings },
    ]);
    static fromBinary(bytes, options) {
        return new UserPayload_Inception().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserPayload_Inception().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserPayload_Inception().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserPayload_Inception, a, b);
    }
}
/**
 * update own membership
 *
 * @generated from message river.UserPayload.UserMembership
 */
export class UserPayload_UserMembership extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: river.MembershipOp op = 2;
     */
    op = MembershipOp.SO_UNSPECIFIED;
    /**
     * @generated from field: optional bytes inviter = 3;
     */
    inviter;
    /**
     * @generated from field: optional bytes stream_parent_id = 4;
     */
    streamParentId;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserPayload.UserMembership";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "op", kind: "enum", T: proto3.getEnumType(MembershipOp) },
        { no: 3, name: "inviter", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
        { no: 4, name: "stream_parent_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    ]);
    static fromBinary(bytes, options) {
        return new UserPayload_UserMembership().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserPayload_UserMembership().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserPayload_UserMembership().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserPayload_UserMembership, a, b);
    }
}
/**
 * update someone else's membership
 *
 * @generated from message river.UserPayload.UserMembershipAction
 */
export class UserPayload_UserMembershipAction extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: bytes user_id = 2;
     */
    userId = new Uint8Array(0);
    /**
     * @generated from field: river.MembershipOp op = 3;
     */
    op = MembershipOp.SO_UNSPECIFIED;
    /**
     * @generated from field: optional bytes stream_parent_id = 4;
     */
    streamParentId;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserPayload.UserMembershipAction";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "user_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 3, name: "op", kind: "enum", T: proto3.getEnumType(MembershipOp) },
        { no: 4, name: "stream_parent_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    ]);
    static fromBinary(bytes, options) {
        return new UserPayload_UserMembershipAction().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserPayload_UserMembershipAction().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserPayload_UserMembershipAction().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserPayload_UserMembershipAction, a, b);
    }
}
/**
 * *
 * UserInboxPayload
 * messages to a user encrypted per deviceId
 *
 * @generated from message river.UserInboxPayload
 */
export class UserInboxPayload extends Message {
    /**
     * @generated from oneof river.UserInboxPayload.content
     */
    content = { case: undefined };
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserInboxPayload";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: UserInboxPayload_Inception, oneof: "content" },
        { no: 2, name: "ack", kind: "message", T: UserInboxPayload_Ack, oneof: "content" },
        { no: 3, name: "group_encryption_sessions", kind: "message", T: UserInboxPayload_GroupEncryptionSessions, oneof: "content" },
    ]);
    static fromBinary(bytes, options) {
        return new UserInboxPayload().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserInboxPayload().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserInboxPayload().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserInboxPayload, a, b);
    }
}
/**
 * @generated from message river.UserInboxPayload.Snapshot
 */
export class UserInboxPayload_Snapshot extends Message {
    /**
     * @generated from field: river.UserInboxPayload.Inception inception = 1;
     */
    inception;
    /**
     * deviceKey: miniblockNum that the ack was snapshotted
     *
     * @generated from field: map<string, river.UserInboxPayload.Snapshot.DeviceSummary> device_summary = 2;
     */
    deviceSummary = {};
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserInboxPayload.Snapshot";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: UserInboxPayload_Inception },
        { no: 2, name: "device_summary", kind: "map", K: 9 /* ScalarType.STRING */, V: { kind: "message", T: UserInboxPayload_Snapshot_DeviceSummary } },
    ]);
    static fromBinary(bytes, options) {
        return new UserInboxPayload_Snapshot().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserInboxPayload_Snapshot().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserInboxPayload_Snapshot().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserInboxPayload_Snapshot, a, b);
    }
}
/**
 * @generated from message river.UserInboxPayload.Snapshot.DeviceSummary
 */
export class UserInboxPayload_Snapshot_DeviceSummary extends Message {
    /**
     * *
     * UpperBound = latest to device event sent from other client per deviceKey
     * LowerBound = latest ack sent by stream owner per deviceKey
     * on ack, if UpperBound <= LowerBound then delete this deviceKey entry from the record
     * on ack or new session, if any device’s lower bound < N generations ago, delete the deviceKey entry from the record
     *
     * @generated from field: int64 lower_bound = 1;
     */
    lowerBound = protoInt64.zero;
    /**
     * @generated from field: int64 upper_bound = 2;
     */
    upperBound = protoInt64.zero;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserInboxPayload.Snapshot.DeviceSummary";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "lower_bound", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
        { no: 2, name: "upper_bound", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    ]);
    static fromBinary(bytes, options) {
        return new UserInboxPayload_Snapshot_DeviceSummary().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserInboxPayload_Snapshot_DeviceSummary().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserInboxPayload_Snapshot_DeviceSummary().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserInboxPayload_Snapshot_DeviceSummary, a, b);
    }
}
/**
 * @generated from message river.UserInboxPayload.Inception
 */
export class UserInboxPayload_Inception extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: river.StreamSettings settings = 2;
     */
    settings;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserInboxPayload.Inception";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "settings", kind: "message", T: StreamSettings },
    ]);
    static fromBinary(bytes, options) {
        return new UserInboxPayload_Inception().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserInboxPayload_Inception().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserInboxPayload_Inception().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserInboxPayload_Inception, a, b);
    }
}
/**
 * @generated from message river.UserInboxPayload.GroupEncryptionSessions
 */
export class UserInboxPayload_GroupEncryptionSessions extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: string sender_key = 2;
     */
    senderKey = "";
    /**
     * @generated from field: repeated string session_ids = 3;
     */
    sessionIds = [];
    /**
     * deviceKey: per device ciphertext of encrypted session keys that match session_ids
     *
     * @generated from field: map<string, string> ciphertexts = 4;
     */
    ciphertexts = {};
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserInboxPayload.GroupEncryptionSessions";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "sender_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 3, name: "session_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
        { no: 4, name: "ciphertexts", kind: "map", K: 9 /* ScalarType.STRING */, V: { kind: "scalar", T: 9 /* ScalarType.STRING */ } },
    ]);
    static fromBinary(bytes, options) {
        return new UserInboxPayload_GroupEncryptionSessions().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserInboxPayload_GroupEncryptionSessions().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserInboxPayload_GroupEncryptionSessions().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserInboxPayload_GroupEncryptionSessions, a, b);
    }
}
/**
 * @generated from message river.UserInboxPayload.Ack
 */
export class UserInboxPayload_Ack extends Message {
    /**
     * @generated from field: string device_key = 1;
     */
    deviceKey = "";
    /**
     * @generated from field: int64 miniblock_num = 2;
     */
    miniblockNum = protoInt64.zero;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserInboxPayload.Ack";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "device_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "miniblock_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    ]);
    static fromBinary(bytes, options) {
        return new UserInboxPayload_Ack().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserInboxPayload_Ack().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserInboxPayload_Ack().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserInboxPayload_Ack, a, b);
    }
}
/**
 * *
 * UserSettingsPayload
 *
 * @generated from message river.UserSettingsPayload
 */
export class UserSettingsPayload extends Message {
    /**
     * @generated from oneof river.UserSettingsPayload.content
     */
    content = { case: undefined };
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserSettingsPayload";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: UserSettingsPayload_Inception, oneof: "content" },
        { no: 2, name: "fully_read_markers", kind: "message", T: UserSettingsPayload_FullyReadMarkers, oneof: "content" },
        { no: 3, name: "user_block", kind: "message", T: UserSettingsPayload_UserBlock, oneof: "content" },
    ]);
    static fromBinary(bytes, options) {
        return new UserSettingsPayload().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserSettingsPayload().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserSettingsPayload().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserSettingsPayload, a, b);
    }
}
/**
 * @generated from message river.UserSettingsPayload.Snapshot
 */
export class UserSettingsPayload_Snapshot extends Message {
    /**
     * inception
     *
     * @generated from field: river.UserSettingsPayload.Inception inception = 1;
     */
    inception;
    /**
     * fullyReadMarkers: sorted by stream_id
     *
     * @generated from field: repeated river.UserSettingsPayload.FullyReadMarkers fully_read_markers = 2;
     */
    fullyReadMarkers = [];
    /**
     * @generated from field: repeated river.UserSettingsPayload.Snapshot.UserBlocks user_blocks_list = 3;
     */
    userBlocksList = [];
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserSettingsPayload.Snapshot";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: UserSettingsPayload_Inception },
        { no: 2, name: "fully_read_markers", kind: "message", T: UserSettingsPayload_FullyReadMarkers, repeated: true },
        { no: 3, name: "user_blocks_list", kind: "message", T: UserSettingsPayload_Snapshot_UserBlocks, repeated: true },
    ]);
    static fromBinary(bytes, options) {
        return new UserSettingsPayload_Snapshot().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserSettingsPayload_Snapshot().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserSettingsPayload_Snapshot().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserSettingsPayload_Snapshot, a, b);
    }
}
/**
 * for a specific blocked user, there might be multiple block or unblock events
 *
 * @generated from message river.UserSettingsPayload.Snapshot.UserBlocks
 */
export class UserSettingsPayload_Snapshot_UserBlocks extends Message {
    /**
     * @generated from field: bytes user_id = 1;
     */
    userId = new Uint8Array(0);
    /**
     * @generated from field: repeated river.UserSettingsPayload.Snapshot.UserBlocks.Block blocks = 2;
     */
    blocks = [];
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserSettingsPayload.Snapshot.UserBlocks";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "user_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "blocks", kind: "message", T: UserSettingsPayload_Snapshot_UserBlocks_Block, repeated: true },
    ]);
    static fromBinary(bytes, options) {
        return new UserSettingsPayload_Snapshot_UserBlocks().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserSettingsPayload_Snapshot_UserBlocks().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserSettingsPayload_Snapshot_UserBlocks().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserSettingsPayload_Snapshot_UserBlocks, a, b);
    }
}
/**
 * @generated from message river.UserSettingsPayload.Snapshot.UserBlocks.Block
 */
export class UserSettingsPayload_Snapshot_UserBlocks_Block extends Message {
    /**
     * @generated from field: bool is_blocked = 1;
     */
    isBlocked = false;
    /**
     * @generated from field: int64 event_num = 2;
     */
    eventNum = protoInt64.zero;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserSettingsPayload.Snapshot.UserBlocks.Block";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "is_blocked", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
        { no: 2, name: "event_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    ]);
    static fromBinary(bytes, options) {
        return new UserSettingsPayload_Snapshot_UserBlocks_Block().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserSettingsPayload_Snapshot_UserBlocks_Block().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserSettingsPayload_Snapshot_UserBlocks_Block().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserSettingsPayload_Snapshot_UserBlocks_Block, a, b);
    }
}
/**
 * @generated from message river.UserSettingsPayload.Inception
 */
export class UserSettingsPayload_Inception extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: river.StreamSettings settings = 2;
     */
    settings;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserSettingsPayload.Inception";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "settings", kind: "message", T: StreamSettings },
    ]);
    static fromBinary(bytes, options) {
        return new UserSettingsPayload_Inception().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserSettingsPayload_Inception().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserSettingsPayload_Inception().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserSettingsPayload_Inception, a, b);
    }
}
/**
 * @generated from message river.UserSettingsPayload.MarkerContent
 */
export class UserSettingsPayload_MarkerContent extends Message {
    /**
     * @generated from field: string data = 1;
     */
    data = "";
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserSettingsPayload.MarkerContent";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "data", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);
    static fromBinary(bytes, options) {
        return new UserSettingsPayload_MarkerContent().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserSettingsPayload_MarkerContent().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserSettingsPayload_MarkerContent().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserSettingsPayload_MarkerContent, a, b);
    }
}
/**
 * @generated from message river.UserSettingsPayload.FullyReadMarkers
 */
export class UserSettingsPayload_FullyReadMarkers extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: river.UserSettingsPayload.MarkerContent content = 2;
     */
    content;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserSettingsPayload.FullyReadMarkers";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "content", kind: "message", T: UserSettingsPayload_MarkerContent },
    ]);
    static fromBinary(bytes, options) {
        return new UserSettingsPayload_FullyReadMarkers().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserSettingsPayload_FullyReadMarkers().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserSettingsPayload_FullyReadMarkers().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserSettingsPayload_FullyReadMarkers, a, b);
    }
}
/**
 * @generated from message river.UserSettingsPayload.UserBlock
 */
export class UserSettingsPayload_UserBlock extends Message {
    /**
     * @generated from field: bytes user_id = 1;
     */
    userId = new Uint8Array(0);
    /**
     * @generated from field: bool is_blocked = 2;
     */
    isBlocked = false;
    /**
     * @generated from field: int64 event_num = 3;
     */
    eventNum = protoInt64.zero;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserSettingsPayload.UserBlock";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "user_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "is_blocked", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
        { no: 3, name: "event_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    ]);
    static fromBinary(bytes, options) {
        return new UserSettingsPayload_UserBlock().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserSettingsPayload_UserBlock().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserSettingsPayload_UserBlock().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserSettingsPayload_UserBlock, a, b);
    }
}
/**
 * *
 * UserDeviceKeyPayload
 *
 * @generated from message river.UserDeviceKeyPayload
 */
export class UserDeviceKeyPayload extends Message {
    /**
     * @generated from oneof river.UserDeviceKeyPayload.content
     */
    content = { case: undefined };
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserDeviceKeyPayload";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: UserDeviceKeyPayload_Inception, oneof: "content" },
        { no: 2, name: "encryption_device", kind: "message", T: UserDeviceKeyPayload_EncryptionDevice, oneof: "content" },
    ]);
    static fromBinary(bytes, options) {
        return new UserDeviceKeyPayload().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserDeviceKeyPayload().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserDeviceKeyPayload().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserDeviceKeyPayload, a, b);
    }
}
/**
 * @generated from message river.UserDeviceKeyPayload.Snapshot
 */
export class UserDeviceKeyPayload_Snapshot extends Message {
    /**
     * inception
     *
     * @generated from field: river.UserDeviceKeyPayload.Inception inception = 1;
     */
    inception;
    /**
     * device keys for this user, unique by device_key, capped at N, most recent last
     *
     * @generated from field: repeated river.UserDeviceKeyPayload.EncryptionDevice encryption_devices = 2;
     */
    encryptionDevices = [];
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserDeviceKeyPayload.Snapshot";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: UserDeviceKeyPayload_Inception },
        { no: 2, name: "encryption_devices", kind: "message", T: UserDeviceKeyPayload_EncryptionDevice, repeated: true },
    ]);
    static fromBinary(bytes, options) {
        return new UserDeviceKeyPayload_Snapshot().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserDeviceKeyPayload_Snapshot().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserDeviceKeyPayload_Snapshot().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserDeviceKeyPayload_Snapshot, a, b);
    }
}
/**
 * @generated from message river.UserDeviceKeyPayload.Inception
 */
export class UserDeviceKeyPayload_Inception extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: river.StreamSettings settings = 2;
     */
    settings;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserDeviceKeyPayload.Inception";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "settings", kind: "message", T: StreamSettings },
    ]);
    static fromBinary(bytes, options) {
        return new UserDeviceKeyPayload_Inception().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserDeviceKeyPayload_Inception().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserDeviceKeyPayload_Inception().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserDeviceKeyPayload_Inception, a, b);
    }
}
/**
 * @generated from message river.UserDeviceKeyPayload.EncryptionDevice
 */
export class UserDeviceKeyPayload_EncryptionDevice extends Message {
    /**
     * @generated from field: string device_key = 1;
     */
    deviceKey = "";
    /**
     * @generated from field: string fallback_key = 2;
     */
    fallbackKey = "";
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.UserDeviceKeyPayload.EncryptionDevice";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "device_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "fallback_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);
    static fromBinary(bytes, options) {
        return new UserDeviceKeyPayload_EncryptionDevice().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new UserDeviceKeyPayload_EncryptionDevice().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new UserDeviceKeyPayload_EncryptionDevice().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(UserDeviceKeyPayload_EncryptionDevice, a, b);
    }
}
/**
 * *
 * MediaPayload
 *
 * @generated from message river.MediaPayload
 */
export class MediaPayload extends Message {
    /**
     * @generated from oneof river.MediaPayload.content
     */
    content = { case: undefined };
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.MediaPayload";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: MediaPayload_Inception, oneof: "content" },
        { no: 2, name: "chunk", kind: "message", T: MediaPayload_Chunk, oneof: "content" },
    ]);
    static fromBinary(bytes, options) {
        return new MediaPayload().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MediaPayload().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MediaPayload().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MediaPayload, a, b);
    }
}
/**
 * @generated from message river.MediaPayload.Snapshot
 */
export class MediaPayload_Snapshot extends Message {
    /**
     * @generated from field: river.MediaPayload.Inception inception = 1;
     */
    inception;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.MediaPayload.Snapshot";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "inception", kind: "message", T: MediaPayload_Inception },
    ]);
    static fromBinary(bytes, options) {
        return new MediaPayload_Snapshot().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MediaPayload_Snapshot().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MediaPayload_Snapshot().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MediaPayload_Snapshot, a, b);
    }
}
/**
 * @generated from message river.MediaPayload.Inception
 */
export class MediaPayload_Inception extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: bytes channel_id = 2;
     */
    channelId = new Uint8Array(0);
    /**
     * @generated from field: int32 chunk_count = 3;
     */
    chunkCount = 0;
    /**
     * @generated from field: river.StreamSettings settings = 4;
     */
    settings;
    /**
     * @generated from field: optional bytes space_id = 5;
     */
    spaceId;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.MediaPayload.Inception";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "channel_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 3, name: "chunk_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
        { no: 4, name: "settings", kind: "message", T: StreamSettings },
        { no: 5, name: "space_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    ]);
    static fromBinary(bytes, options) {
        return new MediaPayload_Inception().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MediaPayload_Inception().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MediaPayload_Inception().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MediaPayload_Inception, a, b);
    }
}
/**
 * @generated from message river.MediaPayload.Chunk
 */
export class MediaPayload_Chunk extends Message {
    /**
     * @generated from field: bytes data = 1;
     */
    data = new Uint8Array(0);
    /**
     * @generated from field: int32 chunk_index = 2;
     */
    chunkIndex = 0;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.MediaPayload.Chunk";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "chunk_index", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    ]);
    static fromBinary(bytes, options) {
        return new MediaPayload_Chunk().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new MediaPayload_Chunk().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new MediaPayload_Chunk().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(MediaPayload_Chunk, a, b);
    }
}
/**
 * *
 * Snapshot contains a summary of all state events up to the most recent miniblock
 *
 * @generated from message river.Snapshot
 */
export class Snapshot extends Message {
    /**
     * @generated from field: river.MemberPayload.Snapshot members = 1;
     */
    members;
    /**
     * @generated from field: int32 snapshot_version = 2;
     */
    snapshotVersion = 0;
    /**
     * Snapshot data specific for each stream type.
     *
     * @generated from oneof river.Snapshot.content
     */
    content = { case: undefined };
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.Snapshot";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "members", kind: "message", T: MemberPayload_Snapshot },
        { no: 2, name: "snapshot_version", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
        { no: 101, name: "space_content", kind: "message", T: SpacePayload_Snapshot, oneof: "content" },
        { no: 102, name: "channel_content", kind: "message", T: ChannelPayload_Snapshot, oneof: "content" },
        { no: 103, name: "user_content", kind: "message", T: UserPayload_Snapshot, oneof: "content" },
        { no: 104, name: "user_settings_content", kind: "message", T: UserSettingsPayload_Snapshot, oneof: "content" },
        { no: 105, name: "user_device_key_content", kind: "message", T: UserDeviceKeyPayload_Snapshot, oneof: "content" },
        { no: 106, name: "media_content", kind: "message", T: MediaPayload_Snapshot, oneof: "content" },
        { no: 107, name: "dm_channel_content", kind: "message", T: DmChannelPayload_Snapshot, oneof: "content" },
        { no: 108, name: "gdm_channel_content", kind: "message", T: GdmChannelPayload_Snapshot, oneof: "content" },
        { no: 109, name: "user_inbox_content", kind: "message", T: UserInboxPayload_Snapshot, oneof: "content" },
    ]);
    static fromBinary(bytes, options) {
        return new Snapshot().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Snapshot().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Snapshot().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Snapshot, a, b);
    }
}
/**
 * *
 * Derived event is produces by server when there should be additional event to compliment
 * received event. For example, when user joins a space through event in the space stream, server will produce a derived event
 * in a user stream to indicate that user joined a particual space.
 *
 * EventRef is used to reference the event that caused the derived event to be produced.
 *
 * @generated from message river.EventRef
 */
export class EventRef extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: bytes hash = 2;
     */
    hash = new Uint8Array(0);
    /**
     * @generated from field: bytes signature = 3;
     */
    signature = new Uint8Array(0);
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.EventRef";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 3, name: "signature", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    ]);
    static fromBinary(bytes, options) {
        return new EventRef().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new EventRef().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new EventRef().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(EventRef, a, b);
    }
}
/**
 * *
 * StreamSettings is a part of inception payload for each stream type.
 *
 * @generated from message river.StreamSettings
 */
export class StreamSettings extends Message {
    /**
     * Test setting for testing with manual miniblock creation through Info debug request.
     *
     * @generated from field: bool disable_miniblock_creation = 1;
     */
    disableMiniblockCreation = false;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.StreamSettings";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "disable_miniblock_creation", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    ]);
    static fromBinary(bytes, options) {
        return new StreamSettings().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new StreamSettings().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new StreamSettings().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(StreamSettings, a, b);
    }
}
/**
 * *
 * EncryptedData
 *
 * @generated from message river.EncryptedData
 */
export class EncryptedData extends Message {
    /**
     * *
     * Ciphertext of the encryption envelope.
     *
     * @generated from field: string ciphertext = 1;
     */
    ciphertext = "";
    /**
     * *
     * Encryption algorithm  used to encrypt this event.
     *
     * @generated from field: string algorithm = 2;
     */
    algorithm = "";
    /**
     * *
     * Sender device public key identifying the sender's device.
     *
     * @generated from field: string sender_key = 3;
     */
    senderKey = "";
    /**
     * *
     * The ID of the session used to encrypt the message.
     *
     * @generated from field: string session_id = 4;
     */
    sessionId = "";
    /**
     * *
     * Optional checksum of the cleartext data.
     *
     * @generated from field: optional string checksum = 5;
     */
    checksum;
    /**
     * *
     * Optional reference to parent event ID
     *
     * @generated from field: optional string ref_event_id = 6;
     */
    refEventId;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.EncryptedData";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "ciphertext", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "algorithm", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 3, name: "sender_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 4, name: "session_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 5, name: "checksum", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
        { no: 6, name: "ref_event_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    ]);
    static fromBinary(bytes, options) {
        return new EncryptedData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new EncryptedData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new EncryptedData().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(EncryptedData, a, b);
    }
}
/**
 * @generated from message river.WrappedEncryptedData
 */
export class WrappedEncryptedData extends Message {
    /**
     * @generated from field: river.EncryptedData data = 1;
     */
    data;
    /**
     * @generated from field: int64 event_num = 2;
     */
    eventNum = protoInt64.zero;
    /**
     * @generated from field: bytes event_hash = 3;
     */
    eventHash = new Uint8Array(0);
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.WrappedEncryptedData";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "data", kind: "message", T: EncryptedData },
        { no: 2, name: "event_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
        { no: 3, name: "event_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    ]);
    static fromBinary(bytes, options) {
        return new WrappedEncryptedData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new WrappedEncryptedData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new WrappedEncryptedData().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(WrappedEncryptedData, a, b);
    }
}
/**
 * @generated from message river.SyncCookie
 */
export class SyncCookie extends Message {
    /**
     * @generated from field: bytes node_address = 1;
     */
    nodeAddress = new Uint8Array(0);
    /**
     * @generated from field: bytes stream_id = 2;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: int64 minipool_gen = 3;
     */
    minipoolGen = protoInt64.zero;
    /**
     * @generated from field: int64 minipool_slot = 4;
     */
    minipoolSlot = protoInt64.zero;
    /**
     * @generated from field: bytes prev_miniblock_hash = 5;
     */
    prevMiniblockHash = new Uint8Array(0);
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.SyncCookie";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "node_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 3, name: "minipool_gen", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
        { no: 4, name: "minipool_slot", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
        { no: 5, name: "prev_miniblock_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    ]);
    static fromBinary(bytes, options) {
        return new SyncCookie().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SyncCookie().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SyncCookie().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SyncCookie, a, b);
    }
}
/**
 * @generated from message river.StreamAndCookie
 */
export class StreamAndCookie extends Message {
    /**
     * @generated from field: repeated river.Envelope events = 1;
     */
    events = [];
    /**
     * @generated from field: river.SyncCookie next_sync_cookie = 2;
     */
    nextSyncCookie;
    /**
     * if non-empty, contains all blocks since the latest snapshot, miniblocks[0].header is the latest snapshot
     *
     * @generated from field: repeated river.Miniblock miniblocks = 3;
     */
    miniblocks = [];
    /**
     * @generated from field: bool sync_reset = 4;
     */
    syncReset = false;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.StreamAndCookie";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "events", kind: "message", T: Envelope, repeated: true },
        { no: 2, name: "next_sync_cookie", kind: "message", T: SyncCookie },
        { no: 3, name: "miniblocks", kind: "message", T: Miniblock, repeated: true },
        { no: 4, name: "sync_reset", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    ]);
    static fromBinary(bytes, options) {
        return new StreamAndCookie().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new StreamAndCookie().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new StreamAndCookie().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(StreamAndCookie, a, b);
    }
}
/**
 * @generated from message river.GetStreamExRequest
 */
export class GetStreamExRequest extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.GetStreamExRequest";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    ]);
    static fromBinary(bytes, options) {
        return new GetStreamExRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new GetStreamExRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new GetStreamExRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(GetStreamExRequest, a, b);
    }
}
/**
 * @generated from message river.Minipool
 */
export class Minipool extends Message {
    /**
     * @generated from field: repeated river.Envelope events = 1;
     */
    events = [];
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.Minipool";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "events", kind: "message", T: Envelope, repeated: true },
    ]);
    static fromBinary(bytes, options) {
        return new Minipool().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Minipool().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Minipool().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(Minipool, a, b);
    }
}
/**
 * GetStreamExResponse is a stream of raw data that represents the current state of the requested stream.
 * These responses represent streams that are not expected to change once finalized, and have a optimized code path
 * for retrieval. Response may potentially be very large, and are streamed back to the client. The client is expected
 * to martial the raw data back into protobuf messages.
 *
 * @generated from message river.GetStreamExResponse
 */
export class GetStreamExResponse extends Message {
    /**
     * @generated from oneof river.GetStreamExResponse.data
     */
    data = { case: undefined };
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.GetStreamExResponse";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "miniblock", kind: "message", T: Miniblock, oneof: "data" },
        { no: 2, name: "minipool", kind: "message", T: Minipool, oneof: "data" },
    ]);
    static fromBinary(bytes, options) {
        return new GetStreamExResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new GetStreamExResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new GetStreamExResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(GetStreamExResponse, a, b);
    }
}
/**
 * @generated from message river.CreateStreamRequest
 */
export class CreateStreamRequest extends Message {
    /**
     * @generated from field: repeated river.Envelope events = 1;
     */
    events = [];
    /**
     * stream_id should match the stream_id in the inception payload of the first event
     *
     * @generated from field: bytes stream_id = 2;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: map<string, bytes> metadata = 3;
     */
    metadata = {};
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.CreateStreamRequest";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "events", kind: "message", T: Envelope, repeated: true },
        { no: 2, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 3, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: { kind: "scalar", T: 12 /* ScalarType.BYTES */ } },
    ]);
    static fromBinary(bytes, options) {
        return new CreateStreamRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new CreateStreamRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new CreateStreamRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(CreateStreamRequest, a, b);
    }
}
/**
 * @generated from message river.CreateStreamResponse
 */
export class CreateStreamResponse extends Message {
    /**
     * all events in current minipool and cookie allowing to sync from the end of the stream
     *
     * @generated from field: river.StreamAndCookie stream = 1;
     */
    stream;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.CreateStreamResponse";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream", kind: "message", T: StreamAndCookie },
    ]);
    static fromBinary(bytes, options) {
        return new CreateStreamResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new CreateStreamResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new CreateStreamResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(CreateStreamResponse, a, b);
    }
}
/**
 * @generated from message river.GetStreamRequest
 */
export class GetStreamRequest extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    /**
     * if optional is true and stream doesn't exist, response will be a nil stream instead of ERROR NOT_FOUND
     *
     * @generated from field: bool optional = 2;
     */
    optional = false;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.GetStreamRequest";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "optional", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    ]);
    static fromBinary(bytes, options) {
        return new GetStreamRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new GetStreamRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new GetStreamRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(GetStreamRequest, a, b);
    }
}
/**
 * @generated from message river.GetStreamResponse
 */
export class GetStreamResponse extends Message {
    /**
     * all events in current minipool and cookie allowing to sync from the end of the stream
     *
     * @generated from field: river.StreamAndCookie stream = 1;
     */
    stream;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.GetStreamResponse";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream", kind: "message", T: StreamAndCookie },
    ]);
    static fromBinary(bytes, options) {
        return new GetStreamResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new GetStreamResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new GetStreamResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(GetStreamResponse, a, b);
    }
}
/**
 * @generated from message river.GetMiniblocksRequest
 */
export class GetMiniblocksRequest extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: int64 fromInclusive = 2;
     */
    fromInclusive = protoInt64.zero;
    /**
     * @generated from field: int64 toExclusive = 3;
     */
    toExclusive = protoInt64.zero;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.GetMiniblocksRequest";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "fromInclusive", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
        { no: 3, name: "toExclusive", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    ]);
    static fromBinary(bytes, options) {
        return new GetMiniblocksRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new GetMiniblocksRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new GetMiniblocksRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(GetMiniblocksRequest, a, b);
    }
}
/**
 * @generated from message river.GetMiniblocksResponse
 */
export class GetMiniblocksResponse extends Message {
    /**
     * @generated from field: repeated river.Miniblock miniblocks = 1;
     */
    miniblocks = [];
    /**
     * terminus: true if there are no more blocks to fetch because they've been garbage collected, or you've reached block 0
     *
     * @generated from field: bool terminus = 2;
     */
    terminus = false;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.GetMiniblocksResponse";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "miniblocks", kind: "message", T: Miniblock, repeated: true },
        { no: 2, name: "terminus", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    ]);
    static fromBinary(bytes, options) {
        return new GetMiniblocksResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new GetMiniblocksResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new GetMiniblocksResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(GetMiniblocksResponse, a, b);
    }
}
/**
 * @generated from message river.GetLastMiniblockHashRequest
 */
export class GetLastMiniblockHashRequest extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.GetLastMiniblockHashRequest";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    ]);
    static fromBinary(bytes, options) {
        return new GetLastMiniblockHashRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new GetLastMiniblockHashRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new GetLastMiniblockHashRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(GetLastMiniblockHashRequest, a, b);
    }
}
/**
 * @generated from message river.GetLastMiniblockHashResponse
 */
export class GetLastMiniblockHashResponse extends Message {
    /**
     * @generated from field: bytes hash = 1;
     */
    hash = new Uint8Array(0);
    /**
     * @generated from field: int64 miniblock_num = 2;
     */
    miniblockNum = protoInt64.zero;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.GetLastMiniblockHashResponse";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "miniblock_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    ]);
    static fromBinary(bytes, options) {
        return new GetLastMiniblockHashResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new GetLastMiniblockHashResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new GetLastMiniblockHashResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(GetLastMiniblockHashResponse, a, b);
    }
}
/**
 * @generated from message river.AddEventRequest
 */
export class AddEventRequest extends Message {
    /**
     * @generated from field: bytes stream_id = 1;
     */
    streamId = new Uint8Array(0);
    /**
     * @generated from field: river.Envelope event = 2;
     */
    event;
    /**
     * if true, response will contain non nil error if event didn't pass validation
     *
     * @generated from field: bool optional = 3;
     */
    optional = false;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.AddEventRequest";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: "event", kind: "message", T: Envelope },
        { no: 3, name: "optional", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    ]);
    static fromBinary(bytes, options) {
        return new AddEventRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new AddEventRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new AddEventRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(AddEventRequest, a, b);
    }
}
/**
 * @generated from message river.AddEventResponse
 */
export class AddEventResponse extends Message {
    /**
     * only set if AddEventRequest.optional is true
     *
     * @generated from field: river.AddEventResponse.Error error = 1;
     */
    error;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.AddEventResponse";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "error", kind: "message", T: AddEventResponse_Error },
    ]);
    static fromBinary(bytes, options) {
        return new AddEventResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new AddEventResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new AddEventResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(AddEventResponse, a, b);
    }
}
/**
 * @generated from message river.AddEventResponse.Error
 */
export class AddEventResponse_Error extends Message {
    /**
     * @generated from field: river.Err code = 1;
     */
    code = Err.ERR_UNSPECIFIED;
    /**
     * @generated from field: string msg = 2;
     */
    msg = "";
    /**
     * @generated from field: repeated string funcs = 3;
     */
    funcs = [];
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.AddEventResponse.Error";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(Err) },
        { no: 2, name: "msg", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 3, name: "funcs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    ]);
    static fromBinary(bytes, options) {
        return new AddEventResponse_Error().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new AddEventResponse_Error().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new AddEventResponse_Error().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(AddEventResponse_Error, a, b);
    }
}
/**
 * @generated from message river.SyncStreamsRequest
 */
export class SyncStreamsRequest extends Message {
    /**
     * @generated from field: repeated river.SyncCookie sync_pos = 1;
     */
    syncPos = [];
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.SyncStreamsRequest";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "sync_pos", kind: "message", T: SyncCookie, repeated: true },
    ]);
    static fromBinary(bytes, options) {
        return new SyncStreamsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SyncStreamsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SyncStreamsRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SyncStreamsRequest, a, b);
    }
}
/**
 * @generated from message river.SyncStreamsResponse
 */
export class SyncStreamsResponse extends Message {
    /**
     * @generated from field: string sync_id = 1;
     */
    syncId = "";
    /**
     * @generated from field: river.SyncOp sync_op = 2;
     */
    syncOp = SyncOp.SYNC_UNSPECIFIED;
    /**
     * @generated from field: river.StreamAndCookie stream = 3;
     */
    stream;
    /**
     * @generated from field: string pong_nonce = 4;
     */
    pongNonce = "";
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.SyncStreamsResponse";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "sync_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "sync_op", kind: "enum", T: proto3.getEnumType(SyncOp) },
        { no: 3, name: "stream", kind: "message", T: StreamAndCookie },
        { no: 4, name: "pong_nonce", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);
    static fromBinary(bytes, options) {
        return new SyncStreamsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SyncStreamsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SyncStreamsResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(SyncStreamsResponse, a, b);
    }
}
/**
 * @generated from message river.AddStreamToSyncRequest
 */
export class AddStreamToSyncRequest extends Message {
    /**
     * @generated from field: string sync_id = 1;
     */
    syncId = "";
    /**
     * @generated from field: river.SyncCookie sync_pos = 2;
     */
    syncPos;
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.AddStreamToSyncRequest";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "sync_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "sync_pos", kind: "message", T: SyncCookie },
    ]);
    static fromBinary(bytes, options) {
        return new AddStreamToSyncRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new AddStreamToSyncRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new AddStreamToSyncRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(AddStreamToSyncRequest, a, b);
    }
}
/**
 * @generated from message river.AddStreamToSyncResponse
 */
export class AddStreamToSyncResponse extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.AddStreamToSyncResponse";
    static fields = proto3.util.newFieldList(() => []);
    static fromBinary(bytes, options) {
        return new AddStreamToSyncResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new AddStreamToSyncResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new AddStreamToSyncResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(AddStreamToSyncResponse, a, b);
    }
}
/**
 * @generated from message river.RemoveStreamFromSyncRequest
 */
export class RemoveStreamFromSyncRequest extends Message {
    /**
     * @generated from field: string sync_id = 1;
     */
    syncId = "";
    /**
     * @generated from field: bytes stream_id = 2;
     */
    streamId = new Uint8Array(0);
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.RemoveStreamFromSyncRequest";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "sync_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    ]);
    static fromBinary(bytes, options) {
        return new RemoveStreamFromSyncRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new RemoveStreamFromSyncRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new RemoveStreamFromSyncRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(RemoveStreamFromSyncRequest, a, b);
    }
}
/**
 * @generated from message river.RemoveStreamFromSyncResponse
 */
export class RemoveStreamFromSyncResponse extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.RemoveStreamFromSyncResponse";
    static fields = proto3.util.newFieldList(() => []);
    static fromBinary(bytes, options) {
        return new RemoveStreamFromSyncResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new RemoveStreamFromSyncResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new RemoveStreamFromSyncResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(RemoveStreamFromSyncResponse, a, b);
    }
}
/**
 * @generated from message river.CancelSyncRequest
 */
export class CancelSyncRequest extends Message {
    /**
     * @generated from field: string sync_id = 1;
     */
    syncId = "";
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.CancelSyncRequest";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "sync_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);
    static fromBinary(bytes, options) {
        return new CancelSyncRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new CancelSyncRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new CancelSyncRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(CancelSyncRequest, a, b);
    }
}
/**
 * @generated from message river.CancelSyncResponse
 */
export class CancelSyncResponse extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.CancelSyncResponse";
    static fields = proto3.util.newFieldList(() => []);
    static fromBinary(bytes, options) {
        return new CancelSyncResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new CancelSyncResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new CancelSyncResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(CancelSyncResponse, a, b);
    }
}
/**
 * @generated from message river.PingSyncRequest
 */
export class PingSyncRequest extends Message {
    /**
     * @generated from field: string sync_id = 1;
     */
    syncId = "";
    /**
     * @generated from field: string nonce = 2;
     */
    nonce = "";
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.PingSyncRequest";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "sync_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "nonce", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);
    static fromBinary(bytes, options) {
        return new PingSyncRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new PingSyncRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new PingSyncRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(PingSyncRequest, a, b);
    }
}
/**
 * @generated from message river.PingSyncResponse
 */
export class PingSyncResponse extends Message {
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.PingSyncResponse";
    static fields = proto3.util.newFieldList(() => []);
    static fromBinary(bytes, options) {
        return new PingSyncResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new PingSyncResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new PingSyncResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(PingSyncResponse, a, b);
    }
}
/**
 * @generated from message river.InfoRequest
 */
export class InfoRequest extends Message {
    /**
     * @generated from field: repeated string debug = 1;
     */
    debug = [];
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.InfoRequest";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "debug", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    ]);
    static fromBinary(bytes, options) {
        return new InfoRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new InfoRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new InfoRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(InfoRequest, a, b);
    }
}
/**
 * @generated from message river.InfoResponse
 */
export class InfoResponse extends Message {
    /**
     * @generated from field: string graffiti = 1;
     */
    graffiti = "";
    /**
     * @generated from field: google.protobuf.Timestamp start_time = 2;
     */
    startTime;
    /**
     * @generated from field: string version = 3;
     */
    version = "";
    constructor(data) {
        super();
        proto3.util.initPartial(data, this);
    }
    static runtime = proto3;
    static typeName = "river.InfoResponse";
    static fields = proto3.util.newFieldList(() => [
        { no: 1, name: "graffiti", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "start_time", kind: "message", T: Timestamp },
        { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);
    static fromBinary(bytes, options) {
        return new InfoResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new InfoResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new InfoResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return proto3.util.equals(InfoResponse, a, b);
    }
}
//# sourceMappingURL=protocol_pb.js.map