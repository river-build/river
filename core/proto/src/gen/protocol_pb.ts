// @generated by protoc-gen-es v1.9.0 with parameter "target=ts"
// @generated from file protocol.proto (package river, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Empty, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from enum river.SyncOp
 */
export enum SyncOp {
  /**
   * @generated from enum value: SYNC_UNSPECIFIED = 0;
   */
  SYNC_UNSPECIFIED = 0,

  /**
   * new sync
   *
   * @generated from enum value: SYNC_NEW = 1;
   */
  SYNC_NEW = 1,

  /**
   * close the sync
   *
   * @generated from enum value: SYNC_CLOSE = 2;
   */
  SYNC_CLOSE = 2,

  /**
   * update from server
   *
   * @generated from enum value: SYNC_UPDATE = 3;
   */
  SYNC_UPDATE = 3,

  /**
   * respond to the ping message from the client.
   *
   * @generated from enum value: SYNC_PONG = 4;
   */
  SYNC_PONG = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(SyncOp)
proto3.util.setEnumType(SyncOp, "river.SyncOp", [
  { no: 0, name: "SYNC_UNSPECIFIED" },
  { no: 1, name: "SYNC_NEW" },
  { no: 2, name: "SYNC_CLOSE" },
  { no: 3, name: "SYNC_UPDATE" },
  { no: 4, name: "SYNC_PONG" },
]);

/**
 * @generated from enum river.MembershipOp
 */
export enum MembershipOp {
  /**
   * @generated from enum value: SO_UNSPECIFIED = 0;
   */
  SO_UNSPECIFIED = 0,

  /**
   * @generated from enum value: SO_INVITE = 1;
   */
  SO_INVITE = 1,

  /**
   * @generated from enum value: SO_JOIN = 2;
   */
  SO_JOIN = 2,

  /**
   * @generated from enum value: SO_LEAVE = 3;
   */
  SO_LEAVE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(MembershipOp)
proto3.util.setEnumType(MembershipOp, "river.MembershipOp", [
  { no: 0, name: "SO_UNSPECIFIED" },
  { no: 1, name: "SO_INVITE" },
  { no: 2, name: "SO_JOIN" },
  { no: 3, name: "SO_LEAVE" },
]);

/**
 * @generated from enum river.ChannelOp
 */
export enum ChannelOp {
  /**
   * @generated from enum value: CO_UNSPECIFIED = 0;
   */
  CO_UNSPECIFIED = 0,

  /**
   * @generated from enum value: CO_CREATED = 1;
   */
  CO_CREATED = 1,

  /**
   * @generated from enum value: CO_DELETED = 2;
   */
  CO_DELETED = 2,

  /**
   * @generated from enum value: CO_UPDATED = 4;
   */
  CO_UPDATED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ChannelOp)
proto3.util.setEnumType(ChannelOp, "river.ChannelOp", [
  { no: 0, name: "CO_UNSPECIFIED" },
  { no: 1, name: "CO_CREATED" },
  { no: 2, name: "CO_DELETED" },
  { no: 4, name: "CO_UPDATED" },
]);

/**
 * Codes from 1 to 16 match gRPC/Connect codes.
 *
 * @generated from enum river.Err
 */
export enum Err {
  /**
   * @generated from enum value: ERR_UNSPECIFIED = 0;
   */
  ERR_UNSPECIFIED = 0,

  /**
   * Canceled indicates that the operation was canceled, typically by the
   * caller.
   *
   * @generated from enum value: CANCELED = 1;
   */
  CANCELED = 1,

  /**
   * Unknown indicates that the operation failed for an unknown reason.
   *
   * @generated from enum value: UNKNOWN = 2;
   */
  UNKNOWN = 2,

  /**
   * InvalidArgument indicates that client supplied an invalid argument.
   *
   * @generated from enum value: INVALID_ARGUMENT = 3;
   */
  INVALID_ARGUMENT = 3,

  /**
   * DeadlineExceeded indicates that deadline expired before the operation
   * could complete.
   *
   * @generated from enum value: DEADLINE_EXCEEDED = 4;
   */
  DEADLINE_EXCEEDED = 4,

  /**
   * NotFound indicates that some requested entity (for example, a file or
   * directory) was not found.
   *
   * @generated from enum value: NOT_FOUND = 5;
   */
  NOT_FOUND = 5,

  /**
   * AlreadyExists indicates that client attempted to create an entity (for
   * example, a file or directory) that already exists.
   *
   * @generated from enum value: ALREADY_EXISTS = 6;
   */
  ALREADY_EXISTS = 6,

  /**
   * PermissionDenied indicates that the caller doesn't have permission to
   * execute the specified operation.
   *
   * @generated from enum value: PERMISSION_DENIED = 7;
   */
  PERMISSION_DENIED = 7,

  /**
   * ResourceExhausted indicates that some resource has been exhausted. For
   * example, a per-user quota may be exhausted or the entire file system may
   * be full.
   *
   * @generated from enum value: RESOURCE_EXHAUSTED = 8;
   */
  RESOURCE_EXHAUSTED = 8,

  /**
   * FailedPrecondition indicates that the system is not in a state
   * required for the operation's execution.
   *
   * @generated from enum value: FAILED_PRECONDITION = 9;
   */
  FAILED_PRECONDITION = 9,

  /**
   * Aborted indicates that operation was aborted by the system, usually
   * because of a concurrency issue such as a sequencer check failure or
   * transaction abort.
   *
   * @generated from enum value: ABORTED = 10;
   */
  ABORTED = 10,

  /**
   * OutOfRange indicates that the operation was attempted past the valid
   * range (for example, seeking past end-of-file).
   *
   * @generated from enum value: OUT_OF_RANGE = 11;
   */
  OUT_OF_RANGE = 11,

  /**
   * Unimplemented indicates that the operation isn't implemented,
   * supported, or enabled in this service.
   *
   * @generated from enum value: UNIMPLEMENTED = 12;
   */
  UNIMPLEMENTED = 12,

  /**
   * Internal indicates that some invariants expected by the underlying
   * system have been broken. This code is reserved for serious errors.
   *
   * @generated from enum value: INTERNAL = 13;
   */
  INTERNAL = 13,

  /**
   * Unavailable indicates that the service is currently unavailable. This
   * is usually temporary, so clients can back off and retry idempotent
   * operations.
   *
   * @generated from enum value: UNAVAILABLE = 14;
   */
  UNAVAILABLE = 14,

  /**
   * DataLoss indicates that the operation has resulted in unrecoverable
   * data loss or corruption.
   *
   * @generated from enum value: DATA_LOSS = 15;
   */
  DATA_LOSS = 15,

  /**
   * Unauthenticated indicates that the request does not have valid
   * authentication credentials for the operation.
   *
   * @generated from enum value: UNAUTHENTICATED = 16;
   */
  UNAUTHENTICATED = 16,

  /**
   * @generated from enum value: DEBUG_ERROR = 17;
   */
  DEBUG_ERROR = 17,

  /**
   * @generated from enum value: BAD_STREAM_ID = 18;
   */
  BAD_STREAM_ID = 18,

  /**
   * @generated from enum value: BAD_STREAM_CREATION_PARAMS = 19;
   */
  BAD_STREAM_CREATION_PARAMS = 19,

  /**
   * @generated from enum value: INTERNAL_ERROR_SWITCH = 20;
   */
  INTERNAL_ERROR_SWITCH = 20,

  /**
   * @generated from enum value: BAD_EVENT_ID = 21;
   */
  BAD_EVENT_ID = 21,

  /**
   * @generated from enum value: BAD_EVENT_SIGNATURE = 22;
   */
  BAD_EVENT_SIGNATURE = 22,

  /**
   * @generated from enum value: BAD_HASH_FORMAT = 23;
   */
  BAD_HASH_FORMAT = 23,

  /**
   * @generated from enum value: BAD_PREV_MINIBLOCK_HASH = 24;
   */
  BAD_PREV_MINIBLOCK_HASH = 24,

  /**
   * @generated from enum value: NO_EVENT_SPECIFIED = 25;
   */
  NO_EVENT_SPECIFIED = 25,

  /**
   * @generated from enum value: BAD_EVENT = 26;
   */
  BAD_EVENT = 26,

  /**
   * @generated from enum value: USER_CANT_POST = 27;
   */
  USER_CANT_POST = 27,

  /**
   * @generated from enum value: STREAM_BAD_HASHES = 28;
   */
  STREAM_BAD_HASHES = 28,

  /**
   * @generated from enum value: STREAM_EMPTY = 29;
   */
  STREAM_EMPTY = 29,

  /**
   * @generated from enum value: STREAM_BAD_EVENT = 30;
   */
  STREAM_BAD_EVENT = 30,

  /**
   * @generated from enum value: BAD_DELEGATE_SIG = 31;
   */
  BAD_DELEGATE_SIG = 31,

  /**
   * @generated from enum value: BAD_PUBLIC_KEY = 32;
   */
  BAD_PUBLIC_KEY = 32,

  /**
   * @generated from enum value: BAD_PAYLOAD = 33;
   */
  BAD_PAYLOAD = 33,

  /**
   * @generated from enum value: BAD_HEX_STRING = 34;
   */
  BAD_HEX_STRING = 34,

  /**
   * @generated from enum value: BAD_EVENT_HASH = 35;
   */
  BAD_EVENT_HASH = 35,

  /**
   * @generated from enum value: BAD_SYNC_COOKIE = 36;
   */
  BAD_SYNC_COOKIE = 36,

  /**
   * @generated from enum value: DUPLICATE_EVENT = 37;
   */
  DUPLICATE_EVENT = 37,

  /**
   * @generated from enum value: BAD_BLOCK = 38;
   */
  BAD_BLOCK = 38,

  /**
   * @generated from enum value: STREAM_NO_INCEPTION_EVENT = 39;
   */
  STREAM_NO_INCEPTION_EVENT = 39,

  /**
   * @generated from enum value: BAD_BLOCK_NUMBER = 40;
   */
  BAD_BLOCK_NUMBER = 40,

  /**
   * @generated from enum value: BAD_MINIPOOL_SLOT = 41;
   */
  BAD_MINIPOOL_SLOT = 41,

  /**
   * @generated from enum value: BAD_CREATOR_ADDRESS = 42;
   */
  BAD_CREATOR_ADDRESS = 42,

  /**
   * @generated from enum value: STALE_DELEGATE = 43;
   */
  STALE_DELEGATE = 43,

  /**
   * @generated from enum value: BAD_LINK_WALLET_BAD_SIGNATURE = 44;
   */
  BAD_LINK_WALLET_BAD_SIGNATURE = 44,

  /**
   * @generated from enum value: BAD_ROOT_KEY_ID = 45;
   */
  BAD_ROOT_KEY_ID = 45,

  /**
   * @generated from enum value: UNKNOWN_NODE = 46;
   */
  UNKNOWN_NODE = 46,

  /**
   * @generated from enum value: DB_OPERATION_FAILURE = 47;
   */
  DB_OPERATION_FAILURE = 47,

  /**
   * @generated from enum value: MINIBLOCKS_STORAGE_FAILURE = 48;
   */
  MINIBLOCKS_STORAGE_FAILURE = 48,

  /**
   * @generated from enum value: BAD_ADDRESS = 49;
   */
  BAD_ADDRESS = 49,

  /**
   * @generated from enum value: BUFFER_FULL = 50;
   */
  BUFFER_FULL = 50,

  /**
   * @generated from enum value: BAD_CONFIG = 51;
   */
  BAD_CONFIG = 51,

  /**
   * @generated from enum value: BAD_CONTRACT = 52;
   */
  BAD_CONTRACT = 52,

  /**
   * @generated from enum value: CANNOT_CONNECT = 53;
   */
  CANNOT_CONNECT = 53,

  /**
   * @generated from enum value: CANNOT_GET_LINKED_WALLETS = 54;
   */
  CANNOT_GET_LINKED_WALLETS = 54,

  /**
   * @generated from enum value: CANNOT_CHECK_ENTITLEMENTS = 55;
   */
  CANNOT_CHECK_ENTITLEMENTS = 55,

  /**
   * @generated from enum value: CANNOT_CALL_CONTRACT = 56;
   */
  CANNOT_CALL_CONTRACT = 56,

  /**
   * @generated from enum value: SPACE_DISABLED = 57;
   */
  SPACE_DISABLED = 57,

  /**
   * @generated from enum value: CHANNEL_DISABLED = 58;
   */
  CHANNEL_DISABLED = 58,

  /**
   * @generated from enum value: WRONG_STREAM_TYPE = 59;
   */
  WRONG_STREAM_TYPE = 59,

  /**
   * @generated from enum value: MINIPOOL_MISSING_EVENTS = 60;
   */
  MINIPOOL_MISSING_EVENTS = 60,

  /**
   * @generated from enum value: STREAM_LAST_BLOCK_MISMATCH = 61;
   */
  STREAM_LAST_BLOCK_MISMATCH = 61,

  /**
   * @generated from enum value: DOWNSTREAM_NETWORK_ERROR = 62;
   */
  DOWNSTREAM_NETWORK_ERROR = 62,
}
// Retrieve enum metadata with: proto3.getEnumType(Err)
proto3.util.setEnumType(Err, "river.Err", [
  { no: 0, name: "ERR_UNSPECIFIED" },
  { no: 1, name: "CANCELED" },
  { no: 2, name: "UNKNOWN" },
  { no: 3, name: "INVALID_ARGUMENT" },
  { no: 4, name: "DEADLINE_EXCEEDED" },
  { no: 5, name: "NOT_FOUND" },
  { no: 6, name: "ALREADY_EXISTS" },
  { no: 7, name: "PERMISSION_DENIED" },
  { no: 8, name: "RESOURCE_EXHAUSTED" },
  { no: 9, name: "FAILED_PRECONDITION" },
  { no: 10, name: "ABORTED" },
  { no: 11, name: "OUT_OF_RANGE" },
  { no: 12, name: "UNIMPLEMENTED" },
  { no: 13, name: "INTERNAL" },
  { no: 14, name: "UNAVAILABLE" },
  { no: 15, name: "DATA_LOSS" },
  { no: 16, name: "UNAUTHENTICATED" },
  { no: 17, name: "DEBUG_ERROR" },
  { no: 18, name: "BAD_STREAM_ID" },
  { no: 19, name: "BAD_STREAM_CREATION_PARAMS" },
  { no: 20, name: "INTERNAL_ERROR_SWITCH" },
  { no: 21, name: "BAD_EVENT_ID" },
  { no: 22, name: "BAD_EVENT_SIGNATURE" },
  { no: 23, name: "BAD_HASH_FORMAT" },
  { no: 24, name: "BAD_PREV_MINIBLOCK_HASH" },
  { no: 25, name: "NO_EVENT_SPECIFIED" },
  { no: 26, name: "BAD_EVENT" },
  { no: 27, name: "USER_CANT_POST" },
  { no: 28, name: "STREAM_BAD_HASHES" },
  { no: 29, name: "STREAM_EMPTY" },
  { no: 30, name: "STREAM_BAD_EVENT" },
  { no: 31, name: "BAD_DELEGATE_SIG" },
  { no: 32, name: "BAD_PUBLIC_KEY" },
  { no: 33, name: "BAD_PAYLOAD" },
  { no: 34, name: "BAD_HEX_STRING" },
  { no: 35, name: "BAD_EVENT_HASH" },
  { no: 36, name: "BAD_SYNC_COOKIE" },
  { no: 37, name: "DUPLICATE_EVENT" },
  { no: 38, name: "BAD_BLOCK" },
  { no: 39, name: "STREAM_NO_INCEPTION_EVENT" },
  { no: 40, name: "BAD_BLOCK_NUMBER" },
  { no: 41, name: "BAD_MINIPOOL_SLOT" },
  { no: 42, name: "BAD_CREATOR_ADDRESS" },
  { no: 43, name: "STALE_DELEGATE" },
  { no: 44, name: "BAD_LINK_WALLET_BAD_SIGNATURE" },
  { no: 45, name: "BAD_ROOT_KEY_ID" },
  { no: 46, name: "UNKNOWN_NODE" },
  { no: 47, name: "DB_OPERATION_FAILURE" },
  { no: 48, name: "MINIBLOCKS_STORAGE_FAILURE" },
  { no: 49, name: "BAD_ADDRESS" },
  { no: 50, name: "BUFFER_FULL" },
  { no: 51, name: "BAD_CONFIG" },
  { no: 52, name: "BAD_CONTRACT" },
  { no: 53, name: "CANNOT_CONNECT" },
  { no: 54, name: "CANNOT_GET_LINKED_WALLETS" },
  { no: 55, name: "CANNOT_CHECK_ENTITLEMENTS" },
  { no: 56, name: "CANNOT_CALL_CONTRACT" },
  { no: 57, name: "SPACE_DISABLED" },
  { no: 58, name: "CHANNEL_DISABLED" },
  { no: 59, name: "WRONG_STREAM_TYPE" },
  { no: 60, name: "MINIPOOL_MISSING_EVENTS" },
  { no: 61, name: "STREAM_LAST_BLOCK_MISMATCH" },
  { no: 62, name: "DOWNSTREAM_NETWORK_ERROR" },
]);

/**
 * * 
 * Miniblock contains a list of events and the header event.
 * Events must be in the same order as in the header, which is of type MiniblockHeader.
 * Only signed data (Envelopes) should exist in this data structure.
 *
 * @generated from message river.Miniblock
 */
export class Miniblock extends Message<Miniblock> {
  /**
   * @generated from field: repeated river.Envelope events = 1;
   */
  events: Envelope[] = [];

  /**
   * @generated from field: river.Envelope header = 2;
   */
  header?: Envelope;

  constructor(data?: PartialMessage<Miniblock>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.Miniblock";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "events", kind: "message", T: Envelope, repeated: true },
    { no: 2, name: "header", kind: "message", T: Envelope },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Miniblock {
    return new Miniblock().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Miniblock {
    return new Miniblock().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Miniblock {
    return new Miniblock().fromJsonString(jsonString, options);
  }

  static equals(a: Miniblock | PlainMessage<Miniblock> | undefined, b: Miniblock | PlainMessage<Miniblock> | undefined): boolean {
    return proto3.util.equals(Miniblock, a, b);
  }
}

/**
 * *
 * Envelope contains serialized event, and its hash and signature.
 * hash is used as event id. Subsequent events reference this event by hash.
 * event is a serialized StreamEvent
 *
 * @generated from message river.Envelope
 */
export class Envelope extends Message<Envelope> {
  /**
   * *
   * Hash of event.
   * While hash can be recalculated from the event, having it here explicitely
   * makes it easier to work with event.
   * For the event to be valid, must match hash of event field. 
   *
   * @generated from field: bytes hash = 1;
   */
  hash = new Uint8Array(0);

  /**
   * *
   * Signature.
   * For the event to be valid, signature must match event.creator_address
   * or be signed by the address from evant.delegate_sig.
   *
   * @generated from field: bytes signature = 2;
   */
  signature = new Uint8Array(0);

  /**
   * @generated from field: bytes event = 3;
   */
  event = new Uint8Array(0);

  constructor(data?: PartialMessage<Envelope>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.Envelope";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "signature", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "event", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Envelope {
    return new Envelope().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Envelope {
    return new Envelope().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Envelope {
    return new Envelope().fromJsonString(jsonString, options);
  }

  static equals(a: Envelope | PlainMessage<Envelope> | undefined, b: Envelope | PlainMessage<Envelope> | undefined): boolean {
    return proto3.util.equals(Envelope, a, b);
  }
}

/**
 * *
 * StreamEvent is a single event in the stream.
 *
 * @generated from message river.StreamEvent
 */
export class StreamEvent extends Message<StreamEvent> {
  /**
   * *
   * Address of the creator of the event.
   * For user - address of the user's wallet.
   * For server - address of the server's keypair in staking smart contract.
   *
   * For the event to be valid:
   * If delegate_sig is present, creator_address must match delegate_sig.
   * If delegate_sig is not present, creator_address must match event signature in the Envelope.
   *
   * @generated from field: bytes creator_address = 1;
   */
  creatorAddress = new Uint8Array(0);

  /**
   * *
   * delegate_sig allows event to be signed by a delegate keypair 
   *
   * delegate_sig constains signature of the 
   * public key of the delegate keypair + the delegate_expirary_epoch_ms.
   * User's wallet is used to produce this signature.
   *
   * If present, for the event to be valid:
   * 1. creator_address must match delegate_sig's signer public key
   * 2. delegate_sig should be signed as an Ethereum Signed Message (eip-191)
   *
   * Server nodes sign node-produced events with their own keypair and do not
   * need to use delegate_sig.
   *
   * @generated from field: bytes delegate_sig = 2;
   */
  delegateSig = new Uint8Array(0);

  /**
   * * Salt ensures that similar messages are not hashed to the same value. genId() from id.ts may be used. 
   *
   * @generated from field: bytes salt = 3;
   */
  salt = new Uint8Array(0);

  /**
   * * Hash of a preceding miniblock. Null for the inception event. Must be a recent miniblock 
   *
   * @generated from field: optional bytes prev_miniblock_hash = 4;
   */
  prevMiniblockHash?: Uint8Array;

  /**
   * * CreatedAt is the time when the event was created.
   * NOTE: this value is set by clients and is not reliable for anything other than displaying
   * the value to the user. Never use this value to sort events from different users.  
   *
   * @generated from field: int64 created_at_epoch_ms = 5;
   */
  createdAtEpochMs = protoInt64.zero;

  /**
   * * DelegateExpiry is the time when the delegate signature expires. 
   *
   * @generated from field: int64 delegate_expiry_epoch_ms = 6;
   */
  delegateExpiryEpochMs = protoInt64.zero;

  /**
   * * Variable-type payload. 
   * Payloads should obey the following rules:
   * - payloads should have their own unique type
   * - each payload should have a oneof content field
   * - each payload, with the exception of miniblock header and member payloads
   *     should have an inception field inside the content oneof
   * - each payload should have a unique Inception type
   * - payloads can't violate previous type recursively to inception payload
   *
   * @generated from oneof river.StreamEvent.payload
   */
  payload: {
    /**
     * @generated from field: river.MiniblockHeader miniblock_header = 100;
     */
    value: MiniblockHeader;
    case: "miniblockHeader";
  } | {
    /**
     * @generated from field: river.MemberPayload member_payload = 101;
     */
    value: MemberPayload;
    case: "memberPayload";
  } | {
    /**
     * @generated from field: river.SpacePayload space_payload = 102;
     */
    value: SpacePayload;
    case: "spacePayload";
  } | {
    /**
     * @generated from field: river.ChannelPayload channel_payload = 103;
     */
    value: ChannelPayload;
    case: "channelPayload";
  } | {
    /**
     * @generated from field: river.UserPayload user_payload = 104;
     */
    value: UserPayload;
    case: "userPayload";
  } | {
    /**
     * @generated from field: river.UserSettingsPayload user_settings_payload = 105;
     */
    value: UserSettingsPayload;
    case: "userSettingsPayload";
  } | {
    /**
     * @generated from field: river.UserDeviceKeyPayload user_device_key_payload = 106;
     */
    value: UserDeviceKeyPayload;
    case: "userDeviceKeyPayload";
  } | {
    /**
     * @generated from field: river.UserInboxPayload user_inbox_payload = 107;
     */
    value: UserInboxPayload;
    case: "userInboxPayload";
  } | {
    /**
     * @generated from field: river.MediaPayload media_payload = 108;
     */
    value: MediaPayload;
    case: "mediaPayload";
  } | {
    /**
     * @generated from field: river.DmChannelPayload dm_channel_payload = 109;
     */
    value: DmChannelPayload;
    case: "dmChannelPayload";
  } | {
    /**
     * @generated from field: river.GdmChannelPayload gdm_channel_payload = 110;
     */
    value: GdmChannelPayload;
    case: "gdmChannelPayload";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StreamEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.StreamEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "creator_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "delegate_sig", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "salt", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "prev_miniblock_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 5, name: "created_at_epoch_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "delegate_expiry_epoch_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 100, name: "miniblock_header", kind: "message", T: MiniblockHeader, oneof: "payload" },
    { no: 101, name: "member_payload", kind: "message", T: MemberPayload, oneof: "payload" },
    { no: 102, name: "space_payload", kind: "message", T: SpacePayload, oneof: "payload" },
    { no: 103, name: "channel_payload", kind: "message", T: ChannelPayload, oneof: "payload" },
    { no: 104, name: "user_payload", kind: "message", T: UserPayload, oneof: "payload" },
    { no: 105, name: "user_settings_payload", kind: "message", T: UserSettingsPayload, oneof: "payload" },
    { no: 106, name: "user_device_key_payload", kind: "message", T: UserDeviceKeyPayload, oneof: "payload" },
    { no: 107, name: "user_inbox_payload", kind: "message", T: UserInboxPayload, oneof: "payload" },
    { no: 108, name: "media_payload", kind: "message", T: MediaPayload, oneof: "payload" },
    { no: 109, name: "dm_channel_payload", kind: "message", T: DmChannelPayload, oneof: "payload" },
    { no: 110, name: "gdm_channel_payload", kind: "message", T: GdmChannelPayload, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamEvent {
    return new StreamEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamEvent {
    return new StreamEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamEvent {
    return new StreamEvent().fromJsonString(jsonString, options);
  }

  static equals(a: StreamEvent | PlainMessage<StreamEvent> | undefined, b: StreamEvent | PlainMessage<StreamEvent> | undefined): boolean {
    return proto3.util.equals(StreamEvent, a, b);
  }
}

/**
 * * 
 * MiniblockHeader is a special event that forms a block from set of the stream events.
 * Hash of the serialized StreamEvent containing MiniblockHeader is used as a block hash.
 *
 * @generated from message river.MiniblockHeader
 */
export class MiniblockHeader extends Message<MiniblockHeader> {
  /**
   * Miniblock number.
   * 0 for genesis block.
   * Must be 1 greater than the previous block number.
   *
   * @generated from field: int64 miniblock_num = 1;
   */
  miniblockNum = protoInt64.zero;

  /**
   * Hash of the previous block.
   *
   * @generated from field: bytes prev_miniblock_hash = 2;
   */
  prevMiniblockHash = new Uint8Array(0);

  /**
   * Timestamp of the block.
   * Must be greater than the previous block timestamp.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: Timestamp;

  /**
   * Hashes of the events included in the block.
   *
   * @generated from field: repeated bytes event_hashes = 4;
   */
  eventHashes: Uint8Array[] = [];

  /**
   * Snapshot of the state at the end of the block.
   *
   * @generated from field: optional river.Snapshot snapshot = 5;
   */
  snapshot?: Snapshot;

  /**
   * count of all events in the stream before this block
   *
   * @generated from field: int64 event_num_offset = 6;
   */
  eventNumOffset = protoInt64.zero;

  /**
   * pointer to block with previous snapshot
   *
   * @generated from field: int64 prev_snapshot_miniblock_num = 7;
   */
  prevSnapshotMiniblockNum = protoInt64.zero;

  /**
   * stream payloads are required to have a content field
   *
   * @generated from oneof river.MiniblockHeader.content
   */
  content: {
    /**
     * @generated from field: google.protobuf.Empty none = 100;
     */
    value: Empty;
    case: "none";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MiniblockHeader>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.MiniblockHeader";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "miniblock_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "prev_miniblock_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "timestamp", kind: "message", T: Timestamp },
    { no: 4, name: "event_hashes", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 5, name: "snapshot", kind: "message", T: Snapshot, opt: true },
    { no: 6, name: "event_num_offset", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "prev_snapshot_miniblock_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 100, name: "none", kind: "message", T: Empty, oneof: "content" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MiniblockHeader {
    return new MiniblockHeader().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MiniblockHeader {
    return new MiniblockHeader().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MiniblockHeader {
    return new MiniblockHeader().fromJsonString(jsonString, options);
  }

  static equals(a: MiniblockHeader | PlainMessage<MiniblockHeader> | undefined, b: MiniblockHeader | PlainMessage<MiniblockHeader> | undefined): boolean {
    return proto3.util.equals(MiniblockHeader, a, b);
  }
}

/**
 * *
 * MemberPayload
 * can appear in any stream
 *
 * @generated from message river.MemberPayload
 */
export class MemberPayload extends Message<MemberPayload> {
  /**
   * @generated from oneof river.MemberPayload.content
   */
  content: {
    /**
     * @generated from field: river.MemberPayload.Membership membership = 1;
     */
    value: MemberPayload_Membership;
    case: "membership";
  } | {
    /**
     * @generated from field: river.MemberPayload.KeySolicitation key_solicitation = 2;
     */
    value: MemberPayload_KeySolicitation;
    case: "keySolicitation";
  } | {
    /**
     * @generated from field: river.MemberPayload.KeyFulfillment key_fulfillment = 3;
     */
    value: MemberPayload_KeyFulfillment;
    case: "keyFulfillment";
  } | {
    /**
     * @generated from field: river.EncryptedData username = 4;
     */
    value: EncryptedData;
    case: "username";
  } | {
    /**
     * @generated from field: river.EncryptedData display_name = 5;
     */
    value: EncryptedData;
    case: "displayName";
  } | {
    /**
     * @generated from field: bytes ens_address = 6;
     */
    value: Uint8Array;
    case: "ensAddress";
  } | {
    /**
     * @generated from field: river.MemberPayload.Nft nft = 7;
     */
    value: MemberPayload_Nft;
    case: "nft";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MemberPayload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.MemberPayload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "membership", kind: "message", T: MemberPayload_Membership, oneof: "content" },
    { no: 2, name: "key_solicitation", kind: "message", T: MemberPayload_KeySolicitation, oneof: "content" },
    { no: 3, name: "key_fulfillment", kind: "message", T: MemberPayload_KeyFulfillment, oneof: "content" },
    { no: 4, name: "username", kind: "message", T: EncryptedData, oneof: "content" },
    { no: 5, name: "display_name", kind: "message", T: EncryptedData, oneof: "content" },
    { no: 6, name: "ens_address", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "content" },
    { no: 7, name: "nft", kind: "message", T: MemberPayload_Nft, oneof: "content" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberPayload {
    return new MemberPayload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberPayload {
    return new MemberPayload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberPayload {
    return new MemberPayload().fromJsonString(jsonString, options);
  }

  static equals(a: MemberPayload | PlainMessage<MemberPayload> | undefined, b: MemberPayload | PlainMessage<MemberPayload> | undefined): boolean {
    return proto3.util.equals(MemberPayload, a, b);
  }
}

/**
 * @generated from message river.MemberPayload.Snapshot
 */
export class MemberPayload_Snapshot extends Message<MemberPayload_Snapshot> {
  /**
   * @generated from field: repeated river.MemberPayload.Snapshot.Member joined = 1;
   */
  joined: MemberPayload_Snapshot_Member[] = [];

  constructor(data?: PartialMessage<MemberPayload_Snapshot>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.MemberPayload.Snapshot";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "joined", kind: "message", T: MemberPayload_Snapshot_Member, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberPayload_Snapshot {
    return new MemberPayload_Snapshot().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberPayload_Snapshot {
    return new MemberPayload_Snapshot().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberPayload_Snapshot {
    return new MemberPayload_Snapshot().fromJsonString(jsonString, options);
  }

  static equals(a: MemberPayload_Snapshot | PlainMessage<MemberPayload_Snapshot> | undefined, b: MemberPayload_Snapshot | PlainMessage<MemberPayload_Snapshot> | undefined): boolean {
    return proto3.util.equals(MemberPayload_Snapshot, a, b);
  }
}

/**
 * @generated from message river.MemberPayload.Snapshot.Member
 */
export class MemberPayload_Snapshot_Member extends Message<MemberPayload_Snapshot_Member> {
  /**
   * @generated from field: bytes user_address = 1;
   */
  userAddress = new Uint8Array(0);

  /**
   * @generated from field: int64 miniblock_num = 2;
   */
  miniblockNum = protoInt64.zero;

  /**
   * @generated from field: int64 event_num = 3;
   */
  eventNum = protoInt64.zero;

  /**
   * @generated from field: repeated river.MemberPayload.KeySolicitation solicitations = 4;
   */
  solicitations: MemberPayload_KeySolicitation[] = [];

  /**
   * @generated from field: river.WrappedEncryptedData username = 5;
   */
  username?: WrappedEncryptedData;

  /**
   * @generated from field: river.WrappedEncryptedData display_name = 6;
   */
  displayName?: WrappedEncryptedData;

  /**
   * @generated from field: bytes ens_address = 7;
   */
  ensAddress = new Uint8Array(0);

  /**
   * @generated from field: river.MemberPayload.Nft nft = 8;
   */
  nft?: MemberPayload_Nft;

  constructor(data?: PartialMessage<MemberPayload_Snapshot_Member>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.MemberPayload.Snapshot.Member";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "miniblock_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "event_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "solicitations", kind: "message", T: MemberPayload_KeySolicitation, repeated: true },
    { no: 5, name: "username", kind: "message", T: WrappedEncryptedData },
    { no: 6, name: "display_name", kind: "message", T: WrappedEncryptedData },
    { no: 7, name: "ens_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "nft", kind: "message", T: MemberPayload_Nft },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberPayload_Snapshot_Member {
    return new MemberPayload_Snapshot_Member().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberPayload_Snapshot_Member {
    return new MemberPayload_Snapshot_Member().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberPayload_Snapshot_Member {
    return new MemberPayload_Snapshot_Member().fromJsonString(jsonString, options);
  }

  static equals(a: MemberPayload_Snapshot_Member | PlainMessage<MemberPayload_Snapshot_Member> | undefined, b: MemberPayload_Snapshot_Member | PlainMessage<MemberPayload_Snapshot_Member> | undefined): boolean {
    return proto3.util.equals(MemberPayload_Snapshot_Member, a, b);
  }
}

/**
 * @generated from message river.MemberPayload.Membership
 */
export class MemberPayload_Membership extends Message<MemberPayload_Membership> {
  /**
   * @generated from field: river.MembershipOp op = 1;
   */
  op = MembershipOp.SO_UNSPECIFIED;

  /**
   * @generated from field: bytes user_address = 2;
   */
  userAddress = new Uint8Array(0);

  /**
   * @generated from field: bytes initiator_address = 3;
   */
  initiatorAddress = new Uint8Array(0);

  /**
   * @generated from field: optional bytes stream_parent_id = 4;
   */
  streamParentId?: Uint8Array;

  constructor(data?: PartialMessage<MemberPayload_Membership>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.MemberPayload.Membership";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "op", kind: "enum", T: proto3.getEnumType(MembershipOp) },
    { no: 2, name: "user_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "initiator_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "stream_parent_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberPayload_Membership {
    return new MemberPayload_Membership().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberPayload_Membership {
    return new MemberPayload_Membership().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberPayload_Membership {
    return new MemberPayload_Membership().fromJsonString(jsonString, options);
  }

  static equals(a: MemberPayload_Membership | PlainMessage<MemberPayload_Membership> | undefined, b: MemberPayload_Membership | PlainMessage<MemberPayload_Membership> | undefined): boolean {
    return proto3.util.equals(MemberPayload_Membership, a, b);
  }
}

/**
 * @generated from message river.MemberPayload.KeySolicitation
 */
export class MemberPayload_KeySolicitation extends Message<MemberPayload_KeySolicitation> {
  /**
   * requesters device_key
   *
   * @generated from field: string device_key = 1;
   */
  deviceKey = "";

  /**
   * requesters fallback_key
   *
   * @generated from field: string fallback_key = 2;
   */
  fallbackKey = "";

  /**
   * true if this is a new device, session_ids will be empty
   *
   * @generated from field: bool is_new_device = 3;
   */
  isNewDevice = false;

  /**
   * @generated from field: repeated string session_ids = 4;
   */
  sessionIds: string[] = [];

  constructor(data?: PartialMessage<MemberPayload_KeySolicitation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.MemberPayload.KeySolicitation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "device_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "fallback_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "is_new_device", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "session_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberPayload_KeySolicitation {
    return new MemberPayload_KeySolicitation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberPayload_KeySolicitation {
    return new MemberPayload_KeySolicitation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberPayload_KeySolicitation {
    return new MemberPayload_KeySolicitation().fromJsonString(jsonString, options);
  }

  static equals(a: MemberPayload_KeySolicitation | PlainMessage<MemberPayload_KeySolicitation> | undefined, b: MemberPayload_KeySolicitation | PlainMessage<MemberPayload_KeySolicitation> | undefined): boolean {
    return proto3.util.equals(MemberPayload_KeySolicitation, a, b);
  }
}

/**
 * @generated from message river.MemberPayload.KeyFulfillment
 */
export class MemberPayload_KeyFulfillment extends Message<MemberPayload_KeyFulfillment> {
  /**
   * @generated from field: bytes user_address = 1;
   */
  userAddress = new Uint8Array(0);

  /**
   * @generated from field: string device_key = 2;
   */
  deviceKey = "";

  /**
   * @generated from field: repeated string session_ids = 3;
   */
  sessionIds: string[] = [];

  constructor(data?: PartialMessage<MemberPayload_KeyFulfillment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.MemberPayload.KeyFulfillment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "device_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "session_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberPayload_KeyFulfillment {
    return new MemberPayload_KeyFulfillment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberPayload_KeyFulfillment {
    return new MemberPayload_KeyFulfillment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberPayload_KeyFulfillment {
    return new MemberPayload_KeyFulfillment().fromJsonString(jsonString, options);
  }

  static equals(a: MemberPayload_KeyFulfillment | PlainMessage<MemberPayload_KeyFulfillment> | undefined, b: MemberPayload_KeyFulfillment | PlainMessage<MemberPayload_KeyFulfillment> | undefined): boolean {
    return proto3.util.equals(MemberPayload_KeyFulfillment, a, b);
  }
}

/**
 * @generated from message river.MemberPayload.Nft
 */
export class MemberPayload_Nft extends Message<MemberPayload_Nft> {
  /**
   * @generated from field: int32 chain_id = 1;
   */
  chainId = 0;

  /**
   * @generated from field: bytes contract_address = 2;
   */
  contractAddress = new Uint8Array(0);

  /**
   * @generated from field: bytes token_id = 3;
   */
  tokenId = new Uint8Array(0);

  constructor(data?: PartialMessage<MemberPayload_Nft>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.MemberPayload.Nft";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chain_id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "contract_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "token_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberPayload_Nft {
    return new MemberPayload_Nft().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberPayload_Nft {
    return new MemberPayload_Nft().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberPayload_Nft {
    return new MemberPayload_Nft().fromJsonString(jsonString, options);
  }

  static equals(a: MemberPayload_Nft | PlainMessage<MemberPayload_Nft> | undefined, b: MemberPayload_Nft | PlainMessage<MemberPayload_Nft> | undefined): boolean {
    return proto3.util.equals(MemberPayload_Nft, a, b);
  }
}

/**
 * *
 * SpacePayload
 *
 * @generated from message river.SpacePayload
 */
export class SpacePayload extends Message<SpacePayload> {
  /**
   * @generated from oneof river.SpacePayload.content
   */
  content: {
    /**
     * @generated from field: river.SpacePayload.Inception inception = 1;
     */
    value: SpacePayload_Inception;
    case: "inception";
  } | {
    /**
     * @generated from field: river.SpacePayload.ChannelUpdate channel = 2;
     */
    value: SpacePayload_ChannelUpdate;
    case: "channel";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SpacePayload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.SpacePayload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: SpacePayload_Inception, oneof: "content" },
    { no: 2, name: "channel", kind: "message", T: SpacePayload_ChannelUpdate, oneof: "content" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpacePayload {
    return new SpacePayload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpacePayload {
    return new SpacePayload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpacePayload {
    return new SpacePayload().fromJsonString(jsonString, options);
  }

  static equals(a: SpacePayload | PlainMessage<SpacePayload> | undefined, b: SpacePayload | PlainMessage<SpacePayload> | undefined): boolean {
    return proto3.util.equals(SpacePayload, a, b);
  }
}

/**
 * @generated from message river.SpacePayload.Snapshot
 */
export class SpacePayload_Snapshot extends Message<SpacePayload_Snapshot> {
  /**
   * inception
   *
   * @generated from field: river.SpacePayload.Inception inception = 1;
   */
  inception?: SpacePayload_Inception;

  /**
   * channels: sorted by channel_id
   *
   * @generated from field: repeated river.SpacePayload.ChannelMetadata channels = 2;
   */
  channels: SpacePayload_ChannelMetadata[] = [];

  constructor(data?: PartialMessage<SpacePayload_Snapshot>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.SpacePayload.Snapshot";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: SpacePayload_Inception },
    { no: 2, name: "channels", kind: "message", T: SpacePayload_ChannelMetadata, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpacePayload_Snapshot {
    return new SpacePayload_Snapshot().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpacePayload_Snapshot {
    return new SpacePayload_Snapshot().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpacePayload_Snapshot {
    return new SpacePayload_Snapshot().fromJsonString(jsonString, options);
  }

  static equals(a: SpacePayload_Snapshot | PlainMessage<SpacePayload_Snapshot> | undefined, b: SpacePayload_Snapshot | PlainMessage<SpacePayload_Snapshot> | undefined): boolean {
    return proto3.util.equals(SpacePayload_Snapshot, a, b);
  }
}

/**
 * @generated from message river.SpacePayload.Inception
 */
export class SpacePayload_Inception extends Message<SpacePayload_Inception> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: river.StreamSettings settings = 2;
   */
  settings?: StreamSettings;

  constructor(data?: PartialMessage<SpacePayload_Inception>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.SpacePayload.Inception";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "settings", kind: "message", T: StreamSettings },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpacePayload_Inception {
    return new SpacePayload_Inception().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpacePayload_Inception {
    return new SpacePayload_Inception().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpacePayload_Inception {
    return new SpacePayload_Inception().fromJsonString(jsonString, options);
  }

  static equals(a: SpacePayload_Inception | PlainMessage<SpacePayload_Inception> | undefined, b: SpacePayload_Inception | PlainMessage<SpacePayload_Inception> | undefined): boolean {
    return proto3.util.equals(SpacePayload_Inception, a, b);
  }
}

/**
 * @generated from message river.SpacePayload.ChannelMetadata
 */
export class SpacePayload_ChannelMetadata extends Message<SpacePayload_ChannelMetadata> {
  /**
   * @generated from field: river.ChannelOp op = 1;
   */
  op = ChannelOp.CO_UNSPECIFIED;

  /**
   * @generated from field: bytes channel_id = 2;
   */
  channelId = new Uint8Array(0);

  /**
   * @generated from field: river.EventRef origin_event = 3;
   */
  originEvent?: EventRef;

  /**
   * @generated from field: int64 updated_at_event_num = 6;
   */
  updatedAtEventNum = protoInt64.zero;

  constructor(data?: PartialMessage<SpacePayload_ChannelMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.SpacePayload.ChannelMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "op", kind: "enum", T: proto3.getEnumType(ChannelOp) },
    { no: 2, name: "channel_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "origin_event", kind: "message", T: EventRef },
    { no: 6, name: "updated_at_event_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpacePayload_ChannelMetadata {
    return new SpacePayload_ChannelMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpacePayload_ChannelMetadata {
    return new SpacePayload_ChannelMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpacePayload_ChannelMetadata {
    return new SpacePayload_ChannelMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: SpacePayload_ChannelMetadata | PlainMessage<SpacePayload_ChannelMetadata> | undefined, b: SpacePayload_ChannelMetadata | PlainMessage<SpacePayload_ChannelMetadata> | undefined): boolean {
    return proto3.util.equals(SpacePayload_ChannelMetadata, a, b);
  }
}

/**
 * @generated from message river.SpacePayload.ChannelUpdate
 */
export class SpacePayload_ChannelUpdate extends Message<SpacePayload_ChannelUpdate> {
  /**
   * @generated from field: river.ChannelOp op = 1;
   */
  op = ChannelOp.CO_UNSPECIFIED;

  /**
   * @generated from field: bytes channel_id = 2;
   */
  channelId = new Uint8Array(0);

  /**
   * @generated from field: river.EventRef origin_event = 3;
   */
  originEvent?: EventRef;

  constructor(data?: PartialMessage<SpacePayload_ChannelUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.SpacePayload.ChannelUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "op", kind: "enum", T: proto3.getEnumType(ChannelOp) },
    { no: 2, name: "channel_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "origin_event", kind: "message", T: EventRef },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpacePayload_ChannelUpdate {
    return new SpacePayload_ChannelUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpacePayload_ChannelUpdate {
    return new SpacePayload_ChannelUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpacePayload_ChannelUpdate {
    return new SpacePayload_ChannelUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: SpacePayload_ChannelUpdate | PlainMessage<SpacePayload_ChannelUpdate> | undefined, b: SpacePayload_ChannelUpdate | PlainMessage<SpacePayload_ChannelUpdate> | undefined): boolean {
    return proto3.util.equals(SpacePayload_ChannelUpdate, a, b);
  }
}

/**
 * *
 * ChannelPayload
 *
 * @generated from message river.ChannelPayload
 */
export class ChannelPayload extends Message<ChannelPayload> {
  /**
   * @generated from oneof river.ChannelPayload.content
   */
  content: {
    /**
     * @generated from field: river.ChannelPayload.Inception inception = 1;
     */
    value: ChannelPayload_Inception;
    case: "inception";
  } | {
    /**
     * @generated from field: river.EncryptedData message = 2;
     */
    value: EncryptedData;
    case: "message";
  } | {
    /**
     * @generated from field: river.ChannelPayload.Redaction redaction = 3;
     */
    value: ChannelPayload_Redaction;
    case: "redaction";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ChannelPayload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.ChannelPayload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: ChannelPayload_Inception, oneof: "content" },
    { no: 2, name: "message", kind: "message", T: EncryptedData, oneof: "content" },
    { no: 3, name: "redaction", kind: "message", T: ChannelPayload_Redaction, oneof: "content" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChannelPayload {
    return new ChannelPayload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChannelPayload {
    return new ChannelPayload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChannelPayload {
    return new ChannelPayload().fromJsonString(jsonString, options);
  }

  static equals(a: ChannelPayload | PlainMessage<ChannelPayload> | undefined, b: ChannelPayload | PlainMessage<ChannelPayload> | undefined): boolean {
    return proto3.util.equals(ChannelPayload, a, b);
  }
}

/**
 * @generated from message river.ChannelPayload.Snapshot
 */
export class ChannelPayload_Snapshot extends Message<ChannelPayload_Snapshot> {
  /**
   * inception
   *
   * @generated from field: river.ChannelPayload.Inception inception = 1;
   */
  inception?: ChannelPayload_Inception;

  constructor(data?: PartialMessage<ChannelPayload_Snapshot>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.ChannelPayload.Snapshot";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: ChannelPayload_Inception },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChannelPayload_Snapshot {
    return new ChannelPayload_Snapshot().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChannelPayload_Snapshot {
    return new ChannelPayload_Snapshot().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChannelPayload_Snapshot {
    return new ChannelPayload_Snapshot().fromJsonString(jsonString, options);
  }

  static equals(a: ChannelPayload_Snapshot | PlainMessage<ChannelPayload_Snapshot> | undefined, b: ChannelPayload_Snapshot | PlainMessage<ChannelPayload_Snapshot> | undefined): boolean {
    return proto3.util.equals(ChannelPayload_Snapshot, a, b);
  }
}

/**
 * @generated from message river.ChannelPayload.Inception
 */
export class ChannelPayload_Inception extends Message<ChannelPayload_Inception> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: bytes space_id = 3;
   */
  spaceId = new Uint8Array(0);

  /**
   * @generated from field: river.StreamSettings settings = 5;
   */
  settings?: StreamSettings;

  constructor(data?: PartialMessage<ChannelPayload_Inception>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.ChannelPayload.Inception";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "space_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "settings", kind: "message", T: StreamSettings },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChannelPayload_Inception {
    return new ChannelPayload_Inception().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChannelPayload_Inception {
    return new ChannelPayload_Inception().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChannelPayload_Inception {
    return new ChannelPayload_Inception().fromJsonString(jsonString, options);
  }

  static equals(a: ChannelPayload_Inception | PlainMessage<ChannelPayload_Inception> | undefined, b: ChannelPayload_Inception | PlainMessage<ChannelPayload_Inception> | undefined): boolean {
    return proto3.util.equals(ChannelPayload_Inception, a, b);
  }
}

/**
 * @generated from message river.ChannelPayload.Redaction
 */
export class ChannelPayload_Redaction extends Message<ChannelPayload_Redaction> {
  /**
   * @generated from field: bytes event_id = 1;
   */
  eventId = new Uint8Array(0);

  constructor(data?: PartialMessage<ChannelPayload_Redaction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.ChannelPayload.Redaction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChannelPayload_Redaction {
    return new ChannelPayload_Redaction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChannelPayload_Redaction {
    return new ChannelPayload_Redaction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChannelPayload_Redaction {
    return new ChannelPayload_Redaction().fromJsonString(jsonString, options);
  }

  static equals(a: ChannelPayload_Redaction | PlainMessage<ChannelPayload_Redaction> | undefined, b: ChannelPayload_Redaction | PlainMessage<ChannelPayload_Redaction> | undefined): boolean {
    return proto3.util.equals(ChannelPayload_Redaction, a, b);
  }
}

/**
 * *
 * DmChannelPayload
 *
 * @generated from message river.DmChannelPayload
 */
export class DmChannelPayload extends Message<DmChannelPayload> {
  /**
   * @generated from oneof river.DmChannelPayload.content
   */
  content: {
    /**
     * @generated from field: river.DmChannelPayload.Inception inception = 1;
     */
    value: DmChannelPayload_Inception;
    case: "inception";
  } | {
    /**
     * @generated from field: river.EncryptedData message = 3;
     */
    value: EncryptedData;
    case: "message";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<DmChannelPayload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.DmChannelPayload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: DmChannelPayload_Inception, oneof: "content" },
    { no: 3, name: "message", kind: "message", T: EncryptedData, oneof: "content" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DmChannelPayload {
    return new DmChannelPayload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DmChannelPayload {
    return new DmChannelPayload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DmChannelPayload {
    return new DmChannelPayload().fromJsonString(jsonString, options);
  }

  static equals(a: DmChannelPayload | PlainMessage<DmChannelPayload> | undefined, b: DmChannelPayload | PlainMessage<DmChannelPayload> | undefined): boolean {
    return proto3.util.equals(DmChannelPayload, a, b);
  }
}

/**
 * @generated from message river.DmChannelPayload.Snapshot
 */
export class DmChannelPayload_Snapshot extends Message<DmChannelPayload_Snapshot> {
  /**
   * @generated from field: river.DmChannelPayload.Inception inception = 1;
   */
  inception?: DmChannelPayload_Inception;

  constructor(data?: PartialMessage<DmChannelPayload_Snapshot>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.DmChannelPayload.Snapshot";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: DmChannelPayload_Inception },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DmChannelPayload_Snapshot {
    return new DmChannelPayload_Snapshot().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DmChannelPayload_Snapshot {
    return new DmChannelPayload_Snapshot().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DmChannelPayload_Snapshot {
    return new DmChannelPayload_Snapshot().fromJsonString(jsonString, options);
  }

  static equals(a: DmChannelPayload_Snapshot | PlainMessage<DmChannelPayload_Snapshot> | undefined, b: DmChannelPayload_Snapshot | PlainMessage<DmChannelPayload_Snapshot> | undefined): boolean {
    return proto3.util.equals(DmChannelPayload_Snapshot, a, b);
  }
}

/**
 * @generated from message river.DmChannelPayload.Inception
 */
export class DmChannelPayload_Inception extends Message<DmChannelPayload_Inception> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: bytes first_party_address = 2;
   */
  firstPartyAddress = new Uint8Array(0);

  /**
   * @generated from field: bytes second_party_address = 3;
   */
  secondPartyAddress = new Uint8Array(0);

  /**
   * @generated from field: river.StreamSettings settings = 4;
   */
  settings?: StreamSettings;

  constructor(data?: PartialMessage<DmChannelPayload_Inception>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.DmChannelPayload.Inception";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "first_party_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "second_party_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "settings", kind: "message", T: StreamSettings },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DmChannelPayload_Inception {
    return new DmChannelPayload_Inception().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DmChannelPayload_Inception {
    return new DmChannelPayload_Inception().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DmChannelPayload_Inception {
    return new DmChannelPayload_Inception().fromJsonString(jsonString, options);
  }

  static equals(a: DmChannelPayload_Inception | PlainMessage<DmChannelPayload_Inception> | undefined, b: DmChannelPayload_Inception | PlainMessage<DmChannelPayload_Inception> | undefined): boolean {
    return proto3.util.equals(DmChannelPayload_Inception, a, b);
  }
}

/**
 * *
 * GdmChannelPayload
 *
 * @generated from message river.GdmChannelPayload
 */
export class GdmChannelPayload extends Message<GdmChannelPayload> {
  /**
   * @generated from oneof river.GdmChannelPayload.content
   */
  content: {
    /**
     * @generated from field: river.GdmChannelPayload.Inception inception = 1;
     */
    value: GdmChannelPayload_Inception;
    case: "inception";
  } | {
    /**
     * @generated from field: river.EncryptedData message = 2;
     */
    value: EncryptedData;
    case: "message";
  } | {
    /**
     * @generated from field: river.EncryptedData channel_properties = 3;
     */
    value: EncryptedData;
    case: "channelProperties";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GdmChannelPayload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.GdmChannelPayload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: GdmChannelPayload_Inception, oneof: "content" },
    { no: 2, name: "message", kind: "message", T: EncryptedData, oneof: "content" },
    { no: 3, name: "channel_properties", kind: "message", T: EncryptedData, oneof: "content" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GdmChannelPayload {
    return new GdmChannelPayload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GdmChannelPayload {
    return new GdmChannelPayload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GdmChannelPayload {
    return new GdmChannelPayload().fromJsonString(jsonString, options);
  }

  static equals(a: GdmChannelPayload | PlainMessage<GdmChannelPayload> | undefined, b: GdmChannelPayload | PlainMessage<GdmChannelPayload> | undefined): boolean {
    return proto3.util.equals(GdmChannelPayload, a, b);
  }
}

/**
 * @generated from message river.GdmChannelPayload.Snapshot
 */
export class GdmChannelPayload_Snapshot extends Message<GdmChannelPayload_Snapshot> {
  /**
   * @generated from field: river.GdmChannelPayload.Inception inception = 1;
   */
  inception?: GdmChannelPayload_Inception;

  /**
   * @generated from field: river.WrappedEncryptedData channel_properties = 2;
   */
  channelProperties?: WrappedEncryptedData;

  constructor(data?: PartialMessage<GdmChannelPayload_Snapshot>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.GdmChannelPayload.Snapshot";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: GdmChannelPayload_Inception },
    { no: 2, name: "channel_properties", kind: "message", T: WrappedEncryptedData },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GdmChannelPayload_Snapshot {
    return new GdmChannelPayload_Snapshot().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GdmChannelPayload_Snapshot {
    return new GdmChannelPayload_Snapshot().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GdmChannelPayload_Snapshot {
    return new GdmChannelPayload_Snapshot().fromJsonString(jsonString, options);
  }

  static equals(a: GdmChannelPayload_Snapshot | PlainMessage<GdmChannelPayload_Snapshot> | undefined, b: GdmChannelPayload_Snapshot | PlainMessage<GdmChannelPayload_Snapshot> | undefined): boolean {
    return proto3.util.equals(GdmChannelPayload_Snapshot, a, b);
  }
}

/**
 * @generated from message river.GdmChannelPayload.Inception
 */
export class GdmChannelPayload_Inception extends Message<GdmChannelPayload_Inception> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: river.EncryptedData channel_properties = 2;
   */
  channelProperties?: EncryptedData;

  /**
   * @generated from field: river.StreamSettings settings = 3;
   */
  settings?: StreamSettings;

  constructor(data?: PartialMessage<GdmChannelPayload_Inception>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.GdmChannelPayload.Inception";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "channel_properties", kind: "message", T: EncryptedData },
    { no: 3, name: "settings", kind: "message", T: StreamSettings },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GdmChannelPayload_Inception {
    return new GdmChannelPayload_Inception().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GdmChannelPayload_Inception {
    return new GdmChannelPayload_Inception().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GdmChannelPayload_Inception {
    return new GdmChannelPayload_Inception().fromJsonString(jsonString, options);
  }

  static equals(a: GdmChannelPayload_Inception | PlainMessage<GdmChannelPayload_Inception> | undefined, b: GdmChannelPayload_Inception | PlainMessage<GdmChannelPayload_Inception> | undefined): boolean {
    return proto3.util.equals(GdmChannelPayload_Inception, a, b);
  }
}

/**
 * *
 * UserPayload
 *
 * @generated from message river.UserPayload
 */
export class UserPayload extends Message<UserPayload> {
  /**
   * @generated from oneof river.UserPayload.content
   */
  content: {
    /**
     * @generated from field: river.UserPayload.Inception inception = 1;
     */
    value: UserPayload_Inception;
    case: "inception";
  } | {
    /**
     * @generated from field: river.UserPayload.UserMembership user_membership = 2;
     */
    value: UserPayload_UserMembership;
    case: "userMembership";
  } | {
    /**
     * @generated from field: river.UserPayload.UserMembershipAction user_membership_action = 3;
     */
    value: UserPayload_UserMembershipAction;
    case: "userMembershipAction";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<UserPayload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserPayload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: UserPayload_Inception, oneof: "content" },
    { no: 2, name: "user_membership", kind: "message", T: UserPayload_UserMembership, oneof: "content" },
    { no: 3, name: "user_membership_action", kind: "message", T: UserPayload_UserMembershipAction, oneof: "content" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserPayload {
    return new UserPayload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserPayload {
    return new UserPayload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserPayload {
    return new UserPayload().fromJsonString(jsonString, options);
  }

  static equals(a: UserPayload | PlainMessage<UserPayload> | undefined, b: UserPayload | PlainMessage<UserPayload> | undefined): boolean {
    return proto3.util.equals(UserPayload, a, b);
  }
}

/**
 * @generated from message river.UserPayload.Snapshot
 */
export class UserPayload_Snapshot extends Message<UserPayload_Snapshot> {
  /**
   * inception
   *
   * @generated from field: river.UserPayload.Inception inception = 1;
   */
  inception?: UserPayload_Inception;

  /**
   * memberships, sorted by stream_id
   *
   * @generated from field: repeated river.UserPayload.UserMembership memberships = 2;
   */
  memberships: UserPayload_UserMembership[] = [];

  constructor(data?: PartialMessage<UserPayload_Snapshot>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserPayload.Snapshot";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: UserPayload_Inception },
    { no: 2, name: "memberships", kind: "message", T: UserPayload_UserMembership, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserPayload_Snapshot {
    return new UserPayload_Snapshot().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserPayload_Snapshot {
    return new UserPayload_Snapshot().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserPayload_Snapshot {
    return new UserPayload_Snapshot().fromJsonString(jsonString, options);
  }

  static equals(a: UserPayload_Snapshot | PlainMessage<UserPayload_Snapshot> | undefined, b: UserPayload_Snapshot | PlainMessage<UserPayload_Snapshot> | undefined): boolean {
    return proto3.util.equals(UserPayload_Snapshot, a, b);
  }
}

/**
 * @generated from message river.UserPayload.Inception
 */
export class UserPayload_Inception extends Message<UserPayload_Inception> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: river.StreamSettings settings = 2;
   */
  settings?: StreamSettings;

  constructor(data?: PartialMessage<UserPayload_Inception>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserPayload.Inception";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "settings", kind: "message", T: StreamSettings },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserPayload_Inception {
    return new UserPayload_Inception().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserPayload_Inception {
    return new UserPayload_Inception().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserPayload_Inception {
    return new UserPayload_Inception().fromJsonString(jsonString, options);
  }

  static equals(a: UserPayload_Inception | PlainMessage<UserPayload_Inception> | undefined, b: UserPayload_Inception | PlainMessage<UserPayload_Inception> | undefined): boolean {
    return proto3.util.equals(UserPayload_Inception, a, b);
  }
}

/**
 * update own membership
 *
 * @generated from message river.UserPayload.UserMembership
 */
export class UserPayload_UserMembership extends Message<UserPayload_UserMembership> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: river.MembershipOp op = 2;
   */
  op = MembershipOp.SO_UNSPECIFIED;

  /**
   * @generated from field: optional bytes inviter = 3;
   */
  inviter?: Uint8Array;

  /**
   * @generated from field: optional bytes stream_parent_id = 4;
   */
  streamParentId?: Uint8Array;

  constructor(data?: PartialMessage<UserPayload_UserMembership>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserPayload.UserMembership";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "op", kind: "enum", T: proto3.getEnumType(MembershipOp) },
    { no: 3, name: "inviter", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 4, name: "stream_parent_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserPayload_UserMembership {
    return new UserPayload_UserMembership().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserPayload_UserMembership {
    return new UserPayload_UserMembership().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserPayload_UserMembership {
    return new UserPayload_UserMembership().fromJsonString(jsonString, options);
  }

  static equals(a: UserPayload_UserMembership | PlainMessage<UserPayload_UserMembership> | undefined, b: UserPayload_UserMembership | PlainMessage<UserPayload_UserMembership> | undefined): boolean {
    return proto3.util.equals(UserPayload_UserMembership, a, b);
  }
}

/**
 * update someone else's membership
 *
 * @generated from message river.UserPayload.UserMembershipAction
 */
export class UserPayload_UserMembershipAction extends Message<UserPayload_UserMembershipAction> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: bytes user_id = 2;
   */
  userId = new Uint8Array(0);

  /**
   * @generated from field: river.MembershipOp op = 3;
   */
  op = MembershipOp.SO_UNSPECIFIED;

  /**
   * @generated from field: optional bytes stream_parent_id = 4;
   */
  streamParentId?: Uint8Array;

  constructor(data?: PartialMessage<UserPayload_UserMembershipAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserPayload.UserMembershipAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "user_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "op", kind: "enum", T: proto3.getEnumType(MembershipOp) },
    { no: 4, name: "stream_parent_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserPayload_UserMembershipAction {
    return new UserPayload_UserMembershipAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserPayload_UserMembershipAction {
    return new UserPayload_UserMembershipAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserPayload_UserMembershipAction {
    return new UserPayload_UserMembershipAction().fromJsonString(jsonString, options);
  }

  static equals(a: UserPayload_UserMembershipAction | PlainMessage<UserPayload_UserMembershipAction> | undefined, b: UserPayload_UserMembershipAction | PlainMessage<UserPayload_UserMembershipAction> | undefined): boolean {
    return proto3.util.equals(UserPayload_UserMembershipAction, a, b);
  }
}

/**
 * *
 * UserInboxPayload
 * messages to a user encrypted per deviceId
 *
 * @generated from message river.UserInboxPayload
 */
export class UserInboxPayload extends Message<UserInboxPayload> {
  /**
   * @generated from oneof river.UserInboxPayload.content
   */
  content: {
    /**
     * @generated from field: river.UserInboxPayload.Inception inception = 1;
     */
    value: UserInboxPayload_Inception;
    case: "inception";
  } | {
    /**
     * @generated from field: river.UserInboxPayload.Ack ack = 2;
     */
    value: UserInboxPayload_Ack;
    case: "ack";
  } | {
    /**
     * @generated from field: river.UserInboxPayload.GroupEncryptionSessions group_encryption_sessions = 3;
     */
    value: UserInboxPayload_GroupEncryptionSessions;
    case: "groupEncryptionSessions";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<UserInboxPayload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserInboxPayload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: UserInboxPayload_Inception, oneof: "content" },
    { no: 2, name: "ack", kind: "message", T: UserInboxPayload_Ack, oneof: "content" },
    { no: 3, name: "group_encryption_sessions", kind: "message", T: UserInboxPayload_GroupEncryptionSessions, oneof: "content" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserInboxPayload {
    return new UserInboxPayload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserInboxPayload {
    return new UserInboxPayload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserInboxPayload {
    return new UserInboxPayload().fromJsonString(jsonString, options);
  }

  static equals(a: UserInboxPayload | PlainMessage<UserInboxPayload> | undefined, b: UserInboxPayload | PlainMessage<UserInboxPayload> | undefined): boolean {
    return proto3.util.equals(UserInboxPayload, a, b);
  }
}

/**
 * @generated from message river.UserInboxPayload.Snapshot
 */
export class UserInboxPayload_Snapshot extends Message<UserInboxPayload_Snapshot> {
  /**
   * @generated from field: river.UserInboxPayload.Inception inception = 1;
   */
  inception?: UserInboxPayload_Inception;

  /**
   * deviceKey: miniblockNum that the ack was snapshotted
   *
   * @generated from field: map<string, river.UserInboxPayload.Snapshot.DeviceSummary> device_summary = 2;
   */
  deviceSummary: { [key: string]: UserInboxPayload_Snapshot_DeviceSummary } = {};

  constructor(data?: PartialMessage<UserInboxPayload_Snapshot>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserInboxPayload.Snapshot";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: UserInboxPayload_Inception },
    { no: 2, name: "device_summary", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: UserInboxPayload_Snapshot_DeviceSummary} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserInboxPayload_Snapshot {
    return new UserInboxPayload_Snapshot().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserInboxPayload_Snapshot {
    return new UserInboxPayload_Snapshot().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserInboxPayload_Snapshot {
    return new UserInboxPayload_Snapshot().fromJsonString(jsonString, options);
  }

  static equals(a: UserInboxPayload_Snapshot | PlainMessage<UserInboxPayload_Snapshot> | undefined, b: UserInboxPayload_Snapshot | PlainMessage<UserInboxPayload_Snapshot> | undefined): boolean {
    return proto3.util.equals(UserInboxPayload_Snapshot, a, b);
  }
}

/**
 * @generated from message river.UserInboxPayload.Snapshot.DeviceSummary
 */
export class UserInboxPayload_Snapshot_DeviceSummary extends Message<UserInboxPayload_Snapshot_DeviceSummary> {
  /**
   * *
   * UpperBound = latest to device event sent from other client per deviceKey
   * LowerBound = latest ack sent by stream owner per deviceKey
   * on ack, if UpperBound <= LowerBound then delete this deviceKey entry from the record
   * on ack or new session, if any devices lower bound < N generations ago, delete the deviceKey entry from the record
   *
   * @generated from field: int64 lower_bound = 1;
   */
  lowerBound = protoInt64.zero;

  /**
   * @generated from field: int64 upper_bound = 2;
   */
  upperBound = protoInt64.zero;

  constructor(data?: PartialMessage<UserInboxPayload_Snapshot_DeviceSummary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserInboxPayload.Snapshot.DeviceSummary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "lower_bound", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "upper_bound", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserInboxPayload_Snapshot_DeviceSummary {
    return new UserInboxPayload_Snapshot_DeviceSummary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserInboxPayload_Snapshot_DeviceSummary {
    return new UserInboxPayload_Snapshot_DeviceSummary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserInboxPayload_Snapshot_DeviceSummary {
    return new UserInboxPayload_Snapshot_DeviceSummary().fromJsonString(jsonString, options);
  }

  static equals(a: UserInboxPayload_Snapshot_DeviceSummary | PlainMessage<UserInboxPayload_Snapshot_DeviceSummary> | undefined, b: UserInboxPayload_Snapshot_DeviceSummary | PlainMessage<UserInboxPayload_Snapshot_DeviceSummary> | undefined): boolean {
    return proto3.util.equals(UserInboxPayload_Snapshot_DeviceSummary, a, b);
  }
}

/**
 * @generated from message river.UserInboxPayload.Inception
 */
export class UserInboxPayload_Inception extends Message<UserInboxPayload_Inception> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: river.StreamSettings settings = 2;
   */
  settings?: StreamSettings;

  constructor(data?: PartialMessage<UserInboxPayload_Inception>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserInboxPayload.Inception";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "settings", kind: "message", T: StreamSettings },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserInboxPayload_Inception {
    return new UserInboxPayload_Inception().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserInboxPayload_Inception {
    return new UserInboxPayload_Inception().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserInboxPayload_Inception {
    return new UserInboxPayload_Inception().fromJsonString(jsonString, options);
  }

  static equals(a: UserInboxPayload_Inception | PlainMessage<UserInboxPayload_Inception> | undefined, b: UserInboxPayload_Inception | PlainMessage<UserInboxPayload_Inception> | undefined): boolean {
    return proto3.util.equals(UserInboxPayload_Inception, a, b);
  }
}

/**
 * @generated from message river.UserInboxPayload.GroupEncryptionSessions
 */
export class UserInboxPayload_GroupEncryptionSessions extends Message<UserInboxPayload_GroupEncryptionSessions> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: string sender_key = 2;
   */
  senderKey = "";

  /**
   * @generated from field: repeated string session_ids = 3;
   */
  sessionIds: string[] = [];

  /**
   * deviceKey: per device ciphertext of encrypted session keys that match session_ids 
   *
   * @generated from field: map<string, string> ciphertexts = 4;
   */
  ciphertexts: { [key: string]: string } = {};

  constructor(data?: PartialMessage<UserInboxPayload_GroupEncryptionSessions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserInboxPayload.GroupEncryptionSessions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "sender_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "session_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "ciphertexts", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserInboxPayload_GroupEncryptionSessions {
    return new UserInboxPayload_GroupEncryptionSessions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserInboxPayload_GroupEncryptionSessions {
    return new UserInboxPayload_GroupEncryptionSessions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserInboxPayload_GroupEncryptionSessions {
    return new UserInboxPayload_GroupEncryptionSessions().fromJsonString(jsonString, options);
  }

  static equals(a: UserInboxPayload_GroupEncryptionSessions | PlainMessage<UserInboxPayload_GroupEncryptionSessions> | undefined, b: UserInboxPayload_GroupEncryptionSessions | PlainMessage<UserInboxPayload_GroupEncryptionSessions> | undefined): boolean {
    return proto3.util.equals(UserInboxPayload_GroupEncryptionSessions, a, b);
  }
}

/**
 * @generated from message river.UserInboxPayload.Ack
 */
export class UserInboxPayload_Ack extends Message<UserInboxPayload_Ack> {
  /**
   * @generated from field: string device_key = 1;
   */
  deviceKey = "";

  /**
   * @generated from field: int64 miniblock_num = 2;
   */
  miniblockNum = protoInt64.zero;

  constructor(data?: PartialMessage<UserInboxPayload_Ack>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserInboxPayload.Ack";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "device_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "miniblock_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserInboxPayload_Ack {
    return new UserInboxPayload_Ack().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserInboxPayload_Ack {
    return new UserInboxPayload_Ack().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserInboxPayload_Ack {
    return new UserInboxPayload_Ack().fromJsonString(jsonString, options);
  }

  static equals(a: UserInboxPayload_Ack | PlainMessage<UserInboxPayload_Ack> | undefined, b: UserInboxPayload_Ack | PlainMessage<UserInboxPayload_Ack> | undefined): boolean {
    return proto3.util.equals(UserInboxPayload_Ack, a, b);
  }
}

/**
 * *
 * UserSettingsPayload
 *
 * @generated from message river.UserSettingsPayload
 */
export class UserSettingsPayload extends Message<UserSettingsPayload> {
  /**
   * @generated from oneof river.UserSettingsPayload.content
   */
  content: {
    /**
     * @generated from field: river.UserSettingsPayload.Inception inception = 1;
     */
    value: UserSettingsPayload_Inception;
    case: "inception";
  } | {
    /**
     * @generated from field: river.UserSettingsPayload.FullyReadMarkers fully_read_markers = 2;
     */
    value: UserSettingsPayload_FullyReadMarkers;
    case: "fullyReadMarkers";
  } | {
    /**
     * @generated from field: river.UserSettingsPayload.UserBlock user_block = 3;
     */
    value: UserSettingsPayload_UserBlock;
    case: "userBlock";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<UserSettingsPayload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserSettingsPayload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: UserSettingsPayload_Inception, oneof: "content" },
    { no: 2, name: "fully_read_markers", kind: "message", T: UserSettingsPayload_FullyReadMarkers, oneof: "content" },
    { no: 3, name: "user_block", kind: "message", T: UserSettingsPayload_UserBlock, oneof: "content" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserSettingsPayload {
    return new UserSettingsPayload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserSettingsPayload {
    return new UserSettingsPayload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserSettingsPayload {
    return new UserSettingsPayload().fromJsonString(jsonString, options);
  }

  static equals(a: UserSettingsPayload | PlainMessage<UserSettingsPayload> | undefined, b: UserSettingsPayload | PlainMessage<UserSettingsPayload> | undefined): boolean {
    return proto3.util.equals(UserSettingsPayload, a, b);
  }
}

/**
 * @generated from message river.UserSettingsPayload.Snapshot
 */
export class UserSettingsPayload_Snapshot extends Message<UserSettingsPayload_Snapshot> {
  /**
   * inception
   *
   * @generated from field: river.UserSettingsPayload.Inception inception = 1;
   */
  inception?: UserSettingsPayload_Inception;

  /**
   * fullyReadMarkers: sorted by stream_id
   *
   * @generated from field: repeated river.UserSettingsPayload.FullyReadMarkers fully_read_markers = 2;
   */
  fullyReadMarkers: UserSettingsPayload_FullyReadMarkers[] = [];

  /**
   * @generated from field: repeated river.UserSettingsPayload.Snapshot.UserBlocks user_blocks_list = 3;
   */
  userBlocksList: UserSettingsPayload_Snapshot_UserBlocks[] = [];

  constructor(data?: PartialMessage<UserSettingsPayload_Snapshot>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserSettingsPayload.Snapshot";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: UserSettingsPayload_Inception },
    { no: 2, name: "fully_read_markers", kind: "message", T: UserSettingsPayload_FullyReadMarkers, repeated: true },
    { no: 3, name: "user_blocks_list", kind: "message", T: UserSettingsPayload_Snapshot_UserBlocks, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserSettingsPayload_Snapshot {
    return new UserSettingsPayload_Snapshot().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserSettingsPayload_Snapshot {
    return new UserSettingsPayload_Snapshot().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserSettingsPayload_Snapshot {
    return new UserSettingsPayload_Snapshot().fromJsonString(jsonString, options);
  }

  static equals(a: UserSettingsPayload_Snapshot | PlainMessage<UserSettingsPayload_Snapshot> | undefined, b: UserSettingsPayload_Snapshot | PlainMessage<UserSettingsPayload_Snapshot> | undefined): boolean {
    return proto3.util.equals(UserSettingsPayload_Snapshot, a, b);
  }
}

/**
 * for a specific blocked user, there might be multiple block or unblock events
 *
 * @generated from message river.UserSettingsPayload.Snapshot.UserBlocks
 */
export class UserSettingsPayload_Snapshot_UserBlocks extends Message<UserSettingsPayload_Snapshot_UserBlocks> {
  /**
   * @generated from field: bytes user_id = 1;
   */
  userId = new Uint8Array(0);

  /**
   * @generated from field: repeated river.UserSettingsPayload.Snapshot.UserBlocks.Block blocks = 2;
   */
  blocks: UserSettingsPayload_Snapshot_UserBlocks_Block[] = [];

  constructor(data?: PartialMessage<UserSettingsPayload_Snapshot_UserBlocks>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserSettingsPayload.Snapshot.UserBlocks";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "blocks", kind: "message", T: UserSettingsPayload_Snapshot_UserBlocks_Block, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserSettingsPayload_Snapshot_UserBlocks {
    return new UserSettingsPayload_Snapshot_UserBlocks().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserSettingsPayload_Snapshot_UserBlocks {
    return new UserSettingsPayload_Snapshot_UserBlocks().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserSettingsPayload_Snapshot_UserBlocks {
    return new UserSettingsPayload_Snapshot_UserBlocks().fromJsonString(jsonString, options);
  }

  static equals(a: UserSettingsPayload_Snapshot_UserBlocks | PlainMessage<UserSettingsPayload_Snapshot_UserBlocks> | undefined, b: UserSettingsPayload_Snapshot_UserBlocks | PlainMessage<UserSettingsPayload_Snapshot_UserBlocks> | undefined): boolean {
    return proto3.util.equals(UserSettingsPayload_Snapshot_UserBlocks, a, b);
  }
}

/**
 * @generated from message river.UserSettingsPayload.Snapshot.UserBlocks.Block
 */
export class UserSettingsPayload_Snapshot_UserBlocks_Block extends Message<UserSettingsPayload_Snapshot_UserBlocks_Block> {
  /**
   * @generated from field: bool is_blocked = 1;
   */
  isBlocked = false;

  /**
   * @generated from field: int64 event_num = 2;
   */
  eventNum = protoInt64.zero;

  constructor(data?: PartialMessage<UserSettingsPayload_Snapshot_UserBlocks_Block>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserSettingsPayload.Snapshot.UserBlocks.Block";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_blocked", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "event_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserSettingsPayload_Snapshot_UserBlocks_Block {
    return new UserSettingsPayload_Snapshot_UserBlocks_Block().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserSettingsPayload_Snapshot_UserBlocks_Block {
    return new UserSettingsPayload_Snapshot_UserBlocks_Block().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserSettingsPayload_Snapshot_UserBlocks_Block {
    return new UserSettingsPayload_Snapshot_UserBlocks_Block().fromJsonString(jsonString, options);
  }

  static equals(a: UserSettingsPayload_Snapshot_UserBlocks_Block | PlainMessage<UserSettingsPayload_Snapshot_UserBlocks_Block> | undefined, b: UserSettingsPayload_Snapshot_UserBlocks_Block | PlainMessage<UserSettingsPayload_Snapshot_UserBlocks_Block> | undefined): boolean {
    return proto3.util.equals(UserSettingsPayload_Snapshot_UserBlocks_Block, a, b);
  }
}

/**
 * @generated from message river.UserSettingsPayload.Inception
 */
export class UserSettingsPayload_Inception extends Message<UserSettingsPayload_Inception> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: river.StreamSettings settings = 2;
   */
  settings?: StreamSettings;

  constructor(data?: PartialMessage<UserSettingsPayload_Inception>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserSettingsPayload.Inception";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "settings", kind: "message", T: StreamSettings },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserSettingsPayload_Inception {
    return new UserSettingsPayload_Inception().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserSettingsPayload_Inception {
    return new UserSettingsPayload_Inception().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserSettingsPayload_Inception {
    return new UserSettingsPayload_Inception().fromJsonString(jsonString, options);
  }

  static equals(a: UserSettingsPayload_Inception | PlainMessage<UserSettingsPayload_Inception> | undefined, b: UserSettingsPayload_Inception | PlainMessage<UserSettingsPayload_Inception> | undefined): boolean {
    return proto3.util.equals(UserSettingsPayload_Inception, a, b);
  }
}

/**
 * @generated from message river.UserSettingsPayload.MarkerContent
 */
export class UserSettingsPayload_MarkerContent extends Message<UserSettingsPayload_MarkerContent> {
  /**
   * @generated from field: string data = 1;
   */
  data = "";

  constructor(data?: PartialMessage<UserSettingsPayload_MarkerContent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserSettingsPayload.MarkerContent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserSettingsPayload_MarkerContent {
    return new UserSettingsPayload_MarkerContent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserSettingsPayload_MarkerContent {
    return new UserSettingsPayload_MarkerContent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserSettingsPayload_MarkerContent {
    return new UserSettingsPayload_MarkerContent().fromJsonString(jsonString, options);
  }

  static equals(a: UserSettingsPayload_MarkerContent | PlainMessage<UserSettingsPayload_MarkerContent> | undefined, b: UserSettingsPayload_MarkerContent | PlainMessage<UserSettingsPayload_MarkerContent> | undefined): boolean {
    return proto3.util.equals(UserSettingsPayload_MarkerContent, a, b);
  }
}

/**
 * @generated from message river.UserSettingsPayload.FullyReadMarkers
 */
export class UserSettingsPayload_FullyReadMarkers extends Message<UserSettingsPayload_FullyReadMarkers> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: river.UserSettingsPayload.MarkerContent content = 2;
   */
  content?: UserSettingsPayload_MarkerContent;

  constructor(data?: PartialMessage<UserSettingsPayload_FullyReadMarkers>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserSettingsPayload.FullyReadMarkers";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "content", kind: "message", T: UserSettingsPayload_MarkerContent },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserSettingsPayload_FullyReadMarkers {
    return new UserSettingsPayload_FullyReadMarkers().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserSettingsPayload_FullyReadMarkers {
    return new UserSettingsPayload_FullyReadMarkers().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserSettingsPayload_FullyReadMarkers {
    return new UserSettingsPayload_FullyReadMarkers().fromJsonString(jsonString, options);
  }

  static equals(a: UserSettingsPayload_FullyReadMarkers | PlainMessage<UserSettingsPayload_FullyReadMarkers> | undefined, b: UserSettingsPayload_FullyReadMarkers | PlainMessage<UserSettingsPayload_FullyReadMarkers> | undefined): boolean {
    return proto3.util.equals(UserSettingsPayload_FullyReadMarkers, a, b);
  }
}

/**
 * @generated from message river.UserSettingsPayload.UserBlock
 */
export class UserSettingsPayload_UserBlock extends Message<UserSettingsPayload_UserBlock> {
  /**
   * @generated from field: bytes user_id = 1;
   */
  userId = new Uint8Array(0);

  /**
   * @generated from field: bool is_blocked = 2;
   */
  isBlocked = false;

  /**
   * @generated from field: int64 event_num = 3;
   */
  eventNum = protoInt64.zero;

  constructor(data?: PartialMessage<UserSettingsPayload_UserBlock>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserSettingsPayload.UserBlock";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "is_blocked", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "event_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserSettingsPayload_UserBlock {
    return new UserSettingsPayload_UserBlock().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserSettingsPayload_UserBlock {
    return new UserSettingsPayload_UserBlock().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserSettingsPayload_UserBlock {
    return new UserSettingsPayload_UserBlock().fromJsonString(jsonString, options);
  }

  static equals(a: UserSettingsPayload_UserBlock | PlainMessage<UserSettingsPayload_UserBlock> | undefined, b: UserSettingsPayload_UserBlock | PlainMessage<UserSettingsPayload_UserBlock> | undefined): boolean {
    return proto3.util.equals(UserSettingsPayload_UserBlock, a, b);
  }
}

/**
 * *
 * UserDeviceKeyPayload
 *
 * @generated from message river.UserDeviceKeyPayload
 */
export class UserDeviceKeyPayload extends Message<UserDeviceKeyPayload> {
  /**
   * @generated from oneof river.UserDeviceKeyPayload.content
   */
  content: {
    /**
     * @generated from field: river.UserDeviceKeyPayload.Inception inception = 1;
     */
    value: UserDeviceKeyPayload_Inception;
    case: "inception";
  } | {
    /**
     * @generated from field: river.UserDeviceKeyPayload.EncryptionDevice encryption_device = 2;
     */
    value: UserDeviceKeyPayload_EncryptionDevice;
    case: "encryptionDevice";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<UserDeviceKeyPayload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserDeviceKeyPayload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: UserDeviceKeyPayload_Inception, oneof: "content" },
    { no: 2, name: "encryption_device", kind: "message", T: UserDeviceKeyPayload_EncryptionDevice, oneof: "content" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserDeviceKeyPayload {
    return new UserDeviceKeyPayload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserDeviceKeyPayload {
    return new UserDeviceKeyPayload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserDeviceKeyPayload {
    return new UserDeviceKeyPayload().fromJsonString(jsonString, options);
  }

  static equals(a: UserDeviceKeyPayload | PlainMessage<UserDeviceKeyPayload> | undefined, b: UserDeviceKeyPayload | PlainMessage<UserDeviceKeyPayload> | undefined): boolean {
    return proto3.util.equals(UserDeviceKeyPayload, a, b);
  }
}

/**
 * @generated from message river.UserDeviceKeyPayload.Snapshot
 */
export class UserDeviceKeyPayload_Snapshot extends Message<UserDeviceKeyPayload_Snapshot> {
  /**
   * inception
   *
   * @generated from field: river.UserDeviceKeyPayload.Inception inception = 1;
   */
  inception?: UserDeviceKeyPayload_Inception;

  /**
   * device keys for this user, unique by device_key, capped at N, most recent last
   *
   * @generated from field: repeated river.UserDeviceKeyPayload.EncryptionDevice encryption_devices = 2;
   */
  encryptionDevices: UserDeviceKeyPayload_EncryptionDevice[] = [];

  constructor(data?: PartialMessage<UserDeviceKeyPayload_Snapshot>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserDeviceKeyPayload.Snapshot";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: UserDeviceKeyPayload_Inception },
    { no: 2, name: "encryption_devices", kind: "message", T: UserDeviceKeyPayload_EncryptionDevice, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserDeviceKeyPayload_Snapshot {
    return new UserDeviceKeyPayload_Snapshot().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserDeviceKeyPayload_Snapshot {
    return new UserDeviceKeyPayload_Snapshot().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserDeviceKeyPayload_Snapshot {
    return new UserDeviceKeyPayload_Snapshot().fromJsonString(jsonString, options);
  }

  static equals(a: UserDeviceKeyPayload_Snapshot | PlainMessage<UserDeviceKeyPayload_Snapshot> | undefined, b: UserDeviceKeyPayload_Snapshot | PlainMessage<UserDeviceKeyPayload_Snapshot> | undefined): boolean {
    return proto3.util.equals(UserDeviceKeyPayload_Snapshot, a, b);
  }
}

/**
 * @generated from message river.UserDeviceKeyPayload.Inception
 */
export class UserDeviceKeyPayload_Inception extends Message<UserDeviceKeyPayload_Inception> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: river.StreamSettings settings = 2;
   */
  settings?: StreamSettings;

  constructor(data?: PartialMessage<UserDeviceKeyPayload_Inception>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserDeviceKeyPayload.Inception";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "settings", kind: "message", T: StreamSettings },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserDeviceKeyPayload_Inception {
    return new UserDeviceKeyPayload_Inception().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserDeviceKeyPayload_Inception {
    return new UserDeviceKeyPayload_Inception().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserDeviceKeyPayload_Inception {
    return new UserDeviceKeyPayload_Inception().fromJsonString(jsonString, options);
  }

  static equals(a: UserDeviceKeyPayload_Inception | PlainMessage<UserDeviceKeyPayload_Inception> | undefined, b: UserDeviceKeyPayload_Inception | PlainMessage<UserDeviceKeyPayload_Inception> | undefined): boolean {
    return proto3.util.equals(UserDeviceKeyPayload_Inception, a, b);
  }
}

/**
 * @generated from message river.UserDeviceKeyPayload.EncryptionDevice
 */
export class UserDeviceKeyPayload_EncryptionDevice extends Message<UserDeviceKeyPayload_EncryptionDevice> {
  /**
   * @generated from field: string device_key = 1;
   */
  deviceKey = "";

  /**
   * @generated from field: string fallback_key = 2;
   */
  fallbackKey = "";

  constructor(data?: PartialMessage<UserDeviceKeyPayload_EncryptionDevice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.UserDeviceKeyPayload.EncryptionDevice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "device_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "fallback_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserDeviceKeyPayload_EncryptionDevice {
    return new UserDeviceKeyPayload_EncryptionDevice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserDeviceKeyPayload_EncryptionDevice {
    return new UserDeviceKeyPayload_EncryptionDevice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserDeviceKeyPayload_EncryptionDevice {
    return new UserDeviceKeyPayload_EncryptionDevice().fromJsonString(jsonString, options);
  }

  static equals(a: UserDeviceKeyPayload_EncryptionDevice | PlainMessage<UserDeviceKeyPayload_EncryptionDevice> | undefined, b: UserDeviceKeyPayload_EncryptionDevice | PlainMessage<UserDeviceKeyPayload_EncryptionDevice> | undefined): boolean {
    return proto3.util.equals(UserDeviceKeyPayload_EncryptionDevice, a, b);
  }
}

/**
 * *
 * MediaPayload
 *
 * @generated from message river.MediaPayload
 */
export class MediaPayload extends Message<MediaPayload> {
  /**
   * @generated from oneof river.MediaPayload.content
   */
  content: {
    /**
     * @generated from field: river.MediaPayload.Inception inception = 1;
     */
    value: MediaPayload_Inception;
    case: "inception";
  } | {
    /**
     * @generated from field: river.MediaPayload.Chunk chunk = 2;
     */
    value: MediaPayload_Chunk;
    case: "chunk";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MediaPayload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.MediaPayload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: MediaPayload_Inception, oneof: "content" },
    { no: 2, name: "chunk", kind: "message", T: MediaPayload_Chunk, oneof: "content" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MediaPayload {
    return new MediaPayload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MediaPayload {
    return new MediaPayload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MediaPayload {
    return new MediaPayload().fromJsonString(jsonString, options);
  }

  static equals(a: MediaPayload | PlainMessage<MediaPayload> | undefined, b: MediaPayload | PlainMessage<MediaPayload> | undefined): boolean {
    return proto3.util.equals(MediaPayload, a, b);
  }
}

/**
 * @generated from message river.MediaPayload.Snapshot
 */
export class MediaPayload_Snapshot extends Message<MediaPayload_Snapshot> {
  /**
   * @generated from field: river.MediaPayload.Inception inception = 1;
   */
  inception?: MediaPayload_Inception;

  constructor(data?: PartialMessage<MediaPayload_Snapshot>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.MediaPayload.Snapshot";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inception", kind: "message", T: MediaPayload_Inception },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MediaPayload_Snapshot {
    return new MediaPayload_Snapshot().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MediaPayload_Snapshot {
    return new MediaPayload_Snapshot().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MediaPayload_Snapshot {
    return new MediaPayload_Snapshot().fromJsonString(jsonString, options);
  }

  static equals(a: MediaPayload_Snapshot | PlainMessage<MediaPayload_Snapshot> | undefined, b: MediaPayload_Snapshot | PlainMessage<MediaPayload_Snapshot> | undefined): boolean {
    return proto3.util.equals(MediaPayload_Snapshot, a, b);
  }
}

/**
 * @generated from message river.MediaPayload.Inception
 */
export class MediaPayload_Inception extends Message<MediaPayload_Inception> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: bytes channel_id = 2;
   */
  channelId = new Uint8Array(0);

  /**
   * @generated from field: int32 chunk_count = 3;
   */
  chunkCount = 0;

  /**
   * @generated from field: river.StreamSettings settings = 4;
   */
  settings?: StreamSettings;

  /**
   * @generated from field: optional bytes space_id = 5;
   */
  spaceId?: Uint8Array;

  constructor(data?: PartialMessage<MediaPayload_Inception>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.MediaPayload.Inception";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "channel_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "chunk_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "settings", kind: "message", T: StreamSettings },
    { no: 5, name: "space_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MediaPayload_Inception {
    return new MediaPayload_Inception().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MediaPayload_Inception {
    return new MediaPayload_Inception().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MediaPayload_Inception {
    return new MediaPayload_Inception().fromJsonString(jsonString, options);
  }

  static equals(a: MediaPayload_Inception | PlainMessage<MediaPayload_Inception> | undefined, b: MediaPayload_Inception | PlainMessage<MediaPayload_Inception> | undefined): boolean {
    return proto3.util.equals(MediaPayload_Inception, a, b);
  }
}

/**
 * @generated from message river.MediaPayload.Chunk
 */
export class MediaPayload_Chunk extends Message<MediaPayload_Chunk> {
  /**
   * @generated from field: bytes data = 1;
   */
  data = new Uint8Array(0);

  /**
   * @generated from field: int32 chunk_index = 2;
   */
  chunkIndex = 0;

  constructor(data?: PartialMessage<MediaPayload_Chunk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.MediaPayload.Chunk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "chunk_index", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MediaPayload_Chunk {
    return new MediaPayload_Chunk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MediaPayload_Chunk {
    return new MediaPayload_Chunk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MediaPayload_Chunk {
    return new MediaPayload_Chunk().fromJsonString(jsonString, options);
  }

  static equals(a: MediaPayload_Chunk | PlainMessage<MediaPayload_Chunk> | undefined, b: MediaPayload_Chunk | PlainMessage<MediaPayload_Chunk> | undefined): boolean {
    return proto3.util.equals(MediaPayload_Chunk, a, b);
  }
}

/**
 * *
 * Snapshot contains a summary of all state events up to the most recent miniblock
 *
 * @generated from message river.Snapshot
 */
export class Snapshot extends Message<Snapshot> {
  /**
   * @generated from field: river.MemberPayload.Snapshot members = 1;
   */
  members?: MemberPayload_Snapshot;

  /**
   * @generated from field: int32 snapshot_version = 2;
   */
  snapshotVersion = 0;

  /**
   * Snapshot data specific for each stream type.
   *
   * @generated from oneof river.Snapshot.content
   */
  content: {
    /**
     * @generated from field: river.SpacePayload.Snapshot space_content = 101;
     */
    value: SpacePayload_Snapshot;
    case: "spaceContent";
  } | {
    /**
     * @generated from field: river.ChannelPayload.Snapshot channel_content = 102;
     */
    value: ChannelPayload_Snapshot;
    case: "channelContent";
  } | {
    /**
     * @generated from field: river.UserPayload.Snapshot user_content = 103;
     */
    value: UserPayload_Snapshot;
    case: "userContent";
  } | {
    /**
     * @generated from field: river.UserSettingsPayload.Snapshot user_settings_content = 104;
     */
    value: UserSettingsPayload_Snapshot;
    case: "userSettingsContent";
  } | {
    /**
     * @generated from field: river.UserDeviceKeyPayload.Snapshot user_device_key_content = 105;
     */
    value: UserDeviceKeyPayload_Snapshot;
    case: "userDeviceKeyContent";
  } | {
    /**
     * @generated from field: river.MediaPayload.Snapshot media_content = 106;
     */
    value: MediaPayload_Snapshot;
    case: "mediaContent";
  } | {
    /**
     * @generated from field: river.DmChannelPayload.Snapshot dm_channel_content = 107;
     */
    value: DmChannelPayload_Snapshot;
    case: "dmChannelContent";
  } | {
    /**
     * @generated from field: river.GdmChannelPayload.Snapshot gdm_channel_content = 108;
     */
    value: GdmChannelPayload_Snapshot;
    case: "gdmChannelContent";
  } | {
    /**
     * @generated from field: river.UserInboxPayload.Snapshot user_inbox_content = 109;
     */
    value: UserInboxPayload_Snapshot;
    case: "userInboxContent";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Snapshot>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.Snapshot";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "members", kind: "message", T: MemberPayload_Snapshot },
    { no: 2, name: "snapshot_version", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 101, name: "space_content", kind: "message", T: SpacePayload_Snapshot, oneof: "content" },
    { no: 102, name: "channel_content", kind: "message", T: ChannelPayload_Snapshot, oneof: "content" },
    { no: 103, name: "user_content", kind: "message", T: UserPayload_Snapshot, oneof: "content" },
    { no: 104, name: "user_settings_content", kind: "message", T: UserSettingsPayload_Snapshot, oneof: "content" },
    { no: 105, name: "user_device_key_content", kind: "message", T: UserDeviceKeyPayload_Snapshot, oneof: "content" },
    { no: 106, name: "media_content", kind: "message", T: MediaPayload_Snapshot, oneof: "content" },
    { no: 107, name: "dm_channel_content", kind: "message", T: DmChannelPayload_Snapshot, oneof: "content" },
    { no: 108, name: "gdm_channel_content", kind: "message", T: GdmChannelPayload_Snapshot, oneof: "content" },
    { no: 109, name: "user_inbox_content", kind: "message", T: UserInboxPayload_Snapshot, oneof: "content" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Snapshot {
    return new Snapshot().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Snapshot {
    return new Snapshot().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Snapshot {
    return new Snapshot().fromJsonString(jsonString, options);
  }

  static equals(a: Snapshot | PlainMessage<Snapshot> | undefined, b: Snapshot | PlainMessage<Snapshot> | undefined): boolean {
    return proto3.util.equals(Snapshot, a, b);
  }
}

/**
 * *
 * Derived event is produces by server when there should be additional event to compliment
 * received event. For example, when user joins a space through event in the space stream, server will produce a derived event
 * in a user stream to indicate that user joined a particual space.
 *
 * EventRef is used to reference the event that caused the derived event to be produced.
 *
 * @generated from message river.EventRef
 */
export class EventRef extends Message<EventRef> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: bytes hash = 2;
   */
  hash = new Uint8Array(0);

  /**
   * @generated from field: bytes signature = 3;
   */
  signature = new Uint8Array(0);

  constructor(data?: PartialMessage<EventRef>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.EventRef";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "signature", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventRef {
    return new EventRef().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventRef {
    return new EventRef().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventRef {
    return new EventRef().fromJsonString(jsonString, options);
  }

  static equals(a: EventRef | PlainMessage<EventRef> | undefined, b: EventRef | PlainMessage<EventRef> | undefined): boolean {
    return proto3.util.equals(EventRef, a, b);
  }
}

/**
 * *
 * StreamSettings is a part of inception payload for each stream type.
 *
 * @generated from message river.StreamSettings
 */
export class StreamSettings extends Message<StreamSettings> {
  /**
   * Test setting for testing with manual miniblock creation through Info debug request. 
   *
   * @generated from field: bool disable_miniblock_creation = 1;
   */
  disableMiniblockCreation = false;

  constructor(data?: PartialMessage<StreamSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.StreamSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "disable_miniblock_creation", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamSettings {
    return new StreamSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamSettings {
    return new StreamSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamSettings {
    return new StreamSettings().fromJsonString(jsonString, options);
  }

  static equals(a: StreamSettings | PlainMessage<StreamSettings> | undefined, b: StreamSettings | PlainMessage<StreamSettings> | undefined): boolean {
    return proto3.util.equals(StreamSettings, a, b);
  }
}

/**
 * *
 * EncryptedData
 *
 * @generated from message river.EncryptedData
 */
export class EncryptedData extends Message<EncryptedData> {
  /**
   * *
   * Ciphertext of the encryption envelope.
   *
   * @generated from field: string ciphertext = 1;
   */
  ciphertext = "";

  /**
   * *
   * Encryption algorithm  used to encrypt this event.
   *
   * @generated from field: string algorithm = 2;
   */
  algorithm = "";

  /**
   * *
   * Sender device public key identifying the sender's device.
   *
   * @generated from field: string sender_key = 3;
   */
  senderKey = "";

  /**
   * *
   * The ID of the session used to encrypt the message.
   *
   * @generated from field: string session_id = 4;
   */
  sessionId = "";

  /**
   * *
   * Optional checksum of the cleartext data.
   *
   * @generated from field: optional string checksum = 5;
   */
  checksum?: string;

  /**
   * *
   * Optional reference to parent event ID
   *
   * @generated from field: optional string ref_event_id = 6;
   */
  refEventId?: string;

  constructor(data?: PartialMessage<EncryptedData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.EncryptedData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ciphertext", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "algorithm", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sender_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "session_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "checksum", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "ref_event_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EncryptedData {
    return new EncryptedData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EncryptedData {
    return new EncryptedData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EncryptedData {
    return new EncryptedData().fromJsonString(jsonString, options);
  }

  static equals(a: EncryptedData | PlainMessage<EncryptedData> | undefined, b: EncryptedData | PlainMessage<EncryptedData> | undefined): boolean {
    return proto3.util.equals(EncryptedData, a, b);
  }
}

/**
 * @generated from message river.WrappedEncryptedData
 */
export class WrappedEncryptedData extends Message<WrappedEncryptedData> {
  /**
   * @generated from field: river.EncryptedData data = 1;
   */
  data?: EncryptedData;

  /**
   * @generated from field: int64 event_num = 2;
   */
  eventNum = protoInt64.zero;

  /**
   * @generated from field: bytes event_hash = 3;
   */
  eventHash = new Uint8Array(0);

  constructor(data?: PartialMessage<WrappedEncryptedData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.WrappedEncryptedData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: EncryptedData },
    { no: 2, name: "event_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "event_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WrappedEncryptedData {
    return new WrappedEncryptedData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WrappedEncryptedData {
    return new WrappedEncryptedData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WrappedEncryptedData {
    return new WrappedEncryptedData().fromJsonString(jsonString, options);
  }

  static equals(a: WrappedEncryptedData | PlainMessage<WrappedEncryptedData> | undefined, b: WrappedEncryptedData | PlainMessage<WrappedEncryptedData> | undefined): boolean {
    return proto3.util.equals(WrappedEncryptedData, a, b);
  }
}

/**
 * @generated from message river.SyncCookie
 */
export class SyncCookie extends Message<SyncCookie> {
  /**
   * @generated from field: bytes node_address = 1;
   */
  nodeAddress = new Uint8Array(0);

  /**
   * @generated from field: bytes stream_id = 2;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: int64 minipool_gen = 3;
   */
  minipoolGen = protoInt64.zero;

  /**
   * @generated from field: int64 minipool_slot = 4;
   */
  minipoolSlot = protoInt64.zero;

  /**
   * @generated from field: bytes prev_miniblock_hash = 5;
   */
  prevMiniblockHash = new Uint8Array(0);

  constructor(data?: PartialMessage<SyncCookie>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.SyncCookie";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "node_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "minipool_gen", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "minipool_slot", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "prev_miniblock_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncCookie {
    return new SyncCookie().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncCookie {
    return new SyncCookie().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncCookie {
    return new SyncCookie().fromJsonString(jsonString, options);
  }

  static equals(a: SyncCookie | PlainMessage<SyncCookie> | undefined, b: SyncCookie | PlainMessage<SyncCookie> | undefined): boolean {
    return proto3.util.equals(SyncCookie, a, b);
  }
}

/**
 * @generated from message river.StreamAndCookie
 */
export class StreamAndCookie extends Message<StreamAndCookie> {
  /**
   * @generated from field: repeated river.Envelope events = 1;
   */
  events: Envelope[] = [];

  /**
   * @generated from field: river.SyncCookie next_sync_cookie = 2;
   */
  nextSyncCookie?: SyncCookie;

  /**
   * if non-empty, contains all blocks since the latest snapshot, miniblocks[0].header is the latest snapshot
   *
   * @generated from field: repeated river.Miniblock miniblocks = 3;
   */
  miniblocks: Miniblock[] = [];

  /**
   * @generated from field: bool sync_reset = 4;
   */
  syncReset = false;

  constructor(data?: PartialMessage<StreamAndCookie>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.StreamAndCookie";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "events", kind: "message", T: Envelope, repeated: true },
    { no: 2, name: "next_sync_cookie", kind: "message", T: SyncCookie },
    { no: 3, name: "miniblocks", kind: "message", T: Miniblock, repeated: true },
    { no: 4, name: "sync_reset", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamAndCookie {
    return new StreamAndCookie().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamAndCookie {
    return new StreamAndCookie().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamAndCookie {
    return new StreamAndCookie().fromJsonString(jsonString, options);
  }

  static equals(a: StreamAndCookie | PlainMessage<StreamAndCookie> | undefined, b: StreamAndCookie | PlainMessage<StreamAndCookie> | undefined): boolean {
    return proto3.util.equals(StreamAndCookie, a, b);
  }
}

/**
 * @generated from message river.GetStreamExRequest
 */
export class GetStreamExRequest extends Message<GetStreamExRequest> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  constructor(data?: PartialMessage<GetStreamExRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.GetStreamExRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStreamExRequest {
    return new GetStreamExRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStreamExRequest {
    return new GetStreamExRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStreamExRequest {
    return new GetStreamExRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetStreamExRequest | PlainMessage<GetStreamExRequest> | undefined, b: GetStreamExRequest | PlainMessage<GetStreamExRequest> | undefined): boolean {
    return proto3.util.equals(GetStreamExRequest, a, b);
  }
}

/**
 * @generated from message river.Minipool
 */
export class Minipool extends Message<Minipool> {
  /**
   * @generated from field: repeated river.Envelope events = 1;
   */
  events: Envelope[] = [];

  constructor(data?: PartialMessage<Minipool>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.Minipool";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "events", kind: "message", T: Envelope, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Minipool {
    return new Minipool().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Minipool {
    return new Minipool().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Minipool {
    return new Minipool().fromJsonString(jsonString, options);
  }

  static equals(a: Minipool | PlainMessage<Minipool> | undefined, b: Minipool | PlainMessage<Minipool> | undefined): boolean {
    return proto3.util.equals(Minipool, a, b);
  }
}

/**
 * GetStreamExResponse is a stream of raw data that represents the current state of the requested stream.
 * These responses represent streams that are not expected to change once finalized, and have a optimized code path
 * for retrieval. Response may potentially be very large, and are streamed back to the client. The client is expected
 * to martial the raw data back into protobuf messages.
 *
 * @generated from message river.GetStreamExResponse
 */
export class GetStreamExResponse extends Message<GetStreamExResponse> {
  /**
   * @generated from oneof river.GetStreamExResponse.data
   */
  data: {
    /**
     * @generated from field: river.Miniblock miniblock = 1;
     */
    value: Miniblock;
    case: "miniblock";
  } | {
    /**
     * @generated from field: river.Minipool minipool = 2;
     */
    value: Minipool;
    case: "minipool";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GetStreamExResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.GetStreamExResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "miniblock", kind: "message", T: Miniblock, oneof: "data" },
    { no: 2, name: "minipool", kind: "message", T: Minipool, oneof: "data" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStreamExResponse {
    return new GetStreamExResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStreamExResponse {
    return new GetStreamExResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStreamExResponse {
    return new GetStreamExResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetStreamExResponse | PlainMessage<GetStreamExResponse> | undefined, b: GetStreamExResponse | PlainMessage<GetStreamExResponse> | undefined): boolean {
    return proto3.util.equals(GetStreamExResponse, a, b);
  }
}

/**
 * @generated from message river.CreateStreamRequest
 */
export class CreateStreamRequest extends Message<CreateStreamRequest> {
  /**
   * @generated from field: repeated river.Envelope events = 1;
   */
  events: Envelope[] = [];

  /**
   * stream_id should match the stream_id in the inception payload of the first event
   *
   * @generated from field: bytes stream_id = 2;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: map<string, bytes> metadata = 3;
   */
  metadata: { [key: string]: Uint8Array } = {};

  constructor(data?: PartialMessage<CreateStreamRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.CreateStreamRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "events", kind: "message", T: Envelope, repeated: true },
    { no: 2, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 12 /* ScalarType.BYTES */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateStreamRequest {
    return new CreateStreamRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateStreamRequest {
    return new CreateStreamRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateStreamRequest {
    return new CreateStreamRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateStreamRequest | PlainMessage<CreateStreamRequest> | undefined, b: CreateStreamRequest | PlainMessage<CreateStreamRequest> | undefined): boolean {
    return proto3.util.equals(CreateStreamRequest, a, b);
  }
}

/**
 * @generated from message river.CreateStreamResponse
 */
export class CreateStreamResponse extends Message<CreateStreamResponse> {
  /**
   * all events in current minipool and cookie allowing to sync from the end of the stream
   *
   * @generated from field: river.StreamAndCookie stream = 1;
   */
  stream?: StreamAndCookie;

  constructor(data?: PartialMessage<CreateStreamResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.CreateStreamResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream", kind: "message", T: StreamAndCookie },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateStreamResponse {
    return new CreateStreamResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateStreamResponse {
    return new CreateStreamResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateStreamResponse {
    return new CreateStreamResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateStreamResponse | PlainMessage<CreateStreamResponse> | undefined, b: CreateStreamResponse | PlainMessage<CreateStreamResponse> | undefined): boolean {
    return proto3.util.equals(CreateStreamResponse, a, b);
  }
}

/**
 * @generated from message river.GetStreamRequest
 */
export class GetStreamRequest extends Message<GetStreamRequest> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  /**
   * if optional is true and stream doesn't exist, response will be a nil stream instead of ERROR NOT_FOUND
   *
   * @generated from field: bool optional = 2;
   */
  optional = false;

  constructor(data?: PartialMessage<GetStreamRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.GetStreamRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "optional", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStreamRequest {
    return new GetStreamRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStreamRequest {
    return new GetStreamRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStreamRequest {
    return new GetStreamRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetStreamRequest | PlainMessage<GetStreamRequest> | undefined, b: GetStreamRequest | PlainMessage<GetStreamRequest> | undefined): boolean {
    return proto3.util.equals(GetStreamRequest, a, b);
  }
}

/**
 * @generated from message river.GetStreamResponse
 */
export class GetStreamResponse extends Message<GetStreamResponse> {
  /**
   * all events in current minipool and cookie allowing to sync from the end of the stream
   *
   * @generated from field: river.StreamAndCookie stream = 1;
   */
  stream?: StreamAndCookie;

  constructor(data?: PartialMessage<GetStreamResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.GetStreamResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream", kind: "message", T: StreamAndCookie },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStreamResponse {
    return new GetStreamResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStreamResponse {
    return new GetStreamResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStreamResponse {
    return new GetStreamResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetStreamResponse | PlainMessage<GetStreamResponse> | undefined, b: GetStreamResponse | PlainMessage<GetStreamResponse> | undefined): boolean {
    return proto3.util.equals(GetStreamResponse, a, b);
  }
}

/**
 * @generated from message river.GetMiniblocksRequest
 */
export class GetMiniblocksRequest extends Message<GetMiniblocksRequest> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: int64 fromInclusive = 2;
   */
  fromInclusive = protoInt64.zero;

  /**
   * @generated from field: int64 toExclusive = 3;
   */
  toExclusive = protoInt64.zero;

  constructor(data?: PartialMessage<GetMiniblocksRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.GetMiniblocksRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "fromInclusive", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "toExclusive", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetMiniblocksRequest {
    return new GetMiniblocksRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetMiniblocksRequest {
    return new GetMiniblocksRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetMiniblocksRequest {
    return new GetMiniblocksRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetMiniblocksRequest | PlainMessage<GetMiniblocksRequest> | undefined, b: GetMiniblocksRequest | PlainMessage<GetMiniblocksRequest> | undefined): boolean {
    return proto3.util.equals(GetMiniblocksRequest, a, b);
  }
}

/**
 * @generated from message river.GetMiniblocksResponse
 */
export class GetMiniblocksResponse extends Message<GetMiniblocksResponse> {
  /**
   * @generated from field: repeated river.Miniblock miniblocks = 1;
   */
  miniblocks: Miniblock[] = [];

  /**
   * terminus: true if there are no more blocks to fetch because they've been garbage collected, or you've reached block 0
   *
   * @generated from field: bool terminus = 2;
   */
  terminus = false;

  constructor(data?: PartialMessage<GetMiniblocksResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.GetMiniblocksResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "miniblocks", kind: "message", T: Miniblock, repeated: true },
    { no: 2, name: "terminus", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetMiniblocksResponse {
    return new GetMiniblocksResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetMiniblocksResponse {
    return new GetMiniblocksResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetMiniblocksResponse {
    return new GetMiniblocksResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetMiniblocksResponse | PlainMessage<GetMiniblocksResponse> | undefined, b: GetMiniblocksResponse | PlainMessage<GetMiniblocksResponse> | undefined): boolean {
    return proto3.util.equals(GetMiniblocksResponse, a, b);
  }
}

/**
 * @generated from message river.GetLastMiniblockHashRequest
 */
export class GetLastMiniblockHashRequest extends Message<GetLastMiniblockHashRequest> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  constructor(data?: PartialMessage<GetLastMiniblockHashRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.GetLastMiniblockHashRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLastMiniblockHashRequest {
    return new GetLastMiniblockHashRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLastMiniblockHashRequest {
    return new GetLastMiniblockHashRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLastMiniblockHashRequest {
    return new GetLastMiniblockHashRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetLastMiniblockHashRequest | PlainMessage<GetLastMiniblockHashRequest> | undefined, b: GetLastMiniblockHashRequest | PlainMessage<GetLastMiniblockHashRequest> | undefined): boolean {
    return proto3.util.equals(GetLastMiniblockHashRequest, a, b);
  }
}

/**
 * @generated from message river.GetLastMiniblockHashResponse
 */
export class GetLastMiniblockHashResponse extends Message<GetLastMiniblockHashResponse> {
  /**
   * @generated from field: bytes hash = 1;
   */
  hash = new Uint8Array(0);

  /**
   * @generated from field: int64 miniblock_num = 2;
   */
  miniblockNum = protoInt64.zero;

  constructor(data?: PartialMessage<GetLastMiniblockHashResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.GetLastMiniblockHashResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "miniblock_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLastMiniblockHashResponse {
    return new GetLastMiniblockHashResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLastMiniblockHashResponse {
    return new GetLastMiniblockHashResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLastMiniblockHashResponse {
    return new GetLastMiniblockHashResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetLastMiniblockHashResponse | PlainMessage<GetLastMiniblockHashResponse> | undefined, b: GetLastMiniblockHashResponse | PlainMessage<GetLastMiniblockHashResponse> | undefined): boolean {
    return proto3.util.equals(GetLastMiniblockHashResponse, a, b);
  }
}

/**
 * @generated from message river.AddEventRequest
 */
export class AddEventRequest extends Message<AddEventRequest> {
  /**
   * @generated from field: bytes stream_id = 1;
   */
  streamId = new Uint8Array(0);

  /**
   * @generated from field: river.Envelope event = 2;
   */
  event?: Envelope;

  /**
   * if true, response will contain non nil error if event didn't pass validation
   *
   * @generated from field: bool optional = 3;
   */
  optional = false;

  constructor(data?: PartialMessage<AddEventRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.AddEventRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "event", kind: "message", T: Envelope },
    { no: 3, name: "optional", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddEventRequest {
    return new AddEventRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddEventRequest {
    return new AddEventRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddEventRequest {
    return new AddEventRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AddEventRequest | PlainMessage<AddEventRequest> | undefined, b: AddEventRequest | PlainMessage<AddEventRequest> | undefined): boolean {
    return proto3.util.equals(AddEventRequest, a, b);
  }
}

/**
 * @generated from message river.AddEventResponse
 */
export class AddEventResponse extends Message<AddEventResponse> {
  /**
   * only set if AddEventRequest.optional is true
   *
   * @generated from field: river.AddEventResponse.Error error = 1;
   */
  error?: AddEventResponse_Error;

  constructor(data?: PartialMessage<AddEventResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.AddEventResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error", kind: "message", T: AddEventResponse_Error },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddEventResponse {
    return new AddEventResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddEventResponse {
    return new AddEventResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddEventResponse {
    return new AddEventResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AddEventResponse | PlainMessage<AddEventResponse> | undefined, b: AddEventResponse | PlainMessage<AddEventResponse> | undefined): boolean {
    return proto3.util.equals(AddEventResponse, a, b);
  }
}

/**
 * @generated from message river.AddEventResponse.Error
 */
export class AddEventResponse_Error extends Message<AddEventResponse_Error> {
  /**
   * @generated from field: river.Err code = 1;
   */
  code = Err.ERR_UNSPECIFIED;

  /**
   * @generated from field: string msg = 2;
   */
  msg = "";

  /**
   * @generated from field: repeated string funcs = 3;
   */
  funcs: string[] = [];

  constructor(data?: PartialMessage<AddEventResponse_Error>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.AddEventResponse.Error";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(Err) },
    { no: 2, name: "msg", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "funcs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddEventResponse_Error {
    return new AddEventResponse_Error().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddEventResponse_Error {
    return new AddEventResponse_Error().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddEventResponse_Error {
    return new AddEventResponse_Error().fromJsonString(jsonString, options);
  }

  static equals(a: AddEventResponse_Error | PlainMessage<AddEventResponse_Error> | undefined, b: AddEventResponse_Error | PlainMessage<AddEventResponse_Error> | undefined): boolean {
    return proto3.util.equals(AddEventResponse_Error, a, b);
  }
}

/**
 * @generated from message river.SyncStreamsRequest
 */
export class SyncStreamsRequest extends Message<SyncStreamsRequest> {
  /**
   * @generated from field: repeated river.SyncCookie sync_pos = 1;
   */
  syncPos: SyncCookie[] = [];

  constructor(data?: PartialMessage<SyncStreamsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.SyncStreamsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_pos", kind: "message", T: SyncCookie, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncStreamsRequest {
    return new SyncStreamsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncStreamsRequest {
    return new SyncStreamsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncStreamsRequest {
    return new SyncStreamsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SyncStreamsRequest | PlainMessage<SyncStreamsRequest> | undefined, b: SyncStreamsRequest | PlainMessage<SyncStreamsRequest> | undefined): boolean {
    return proto3.util.equals(SyncStreamsRequest, a, b);
  }
}

/**
 * @generated from message river.SyncStreamsResponse
 */
export class SyncStreamsResponse extends Message<SyncStreamsResponse> {
  /**
   * @generated from field: string sync_id = 1;
   */
  syncId = "";

  /**
   * @generated from field: river.SyncOp sync_op = 2;
   */
  syncOp = SyncOp.SYNC_UNSPECIFIED;

  /**
   * @generated from field: river.StreamAndCookie stream = 3;
   */
  stream?: StreamAndCookie;

  /**
   * @generated from field: string pong_nonce = 4;
   */
  pongNonce = "";

  constructor(data?: PartialMessage<SyncStreamsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.SyncStreamsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sync_op", kind: "enum", T: proto3.getEnumType(SyncOp) },
    { no: 3, name: "stream", kind: "message", T: StreamAndCookie },
    { no: 4, name: "pong_nonce", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncStreamsResponse {
    return new SyncStreamsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncStreamsResponse {
    return new SyncStreamsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncStreamsResponse {
    return new SyncStreamsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SyncStreamsResponse | PlainMessage<SyncStreamsResponse> | undefined, b: SyncStreamsResponse | PlainMessage<SyncStreamsResponse> | undefined): boolean {
    return proto3.util.equals(SyncStreamsResponse, a, b);
  }
}

/**
 * @generated from message river.AddStreamToSyncRequest
 */
export class AddStreamToSyncRequest extends Message<AddStreamToSyncRequest> {
  /**
   * @generated from field: string sync_id = 1;
   */
  syncId = "";

  /**
   * @generated from field: river.SyncCookie sync_pos = 2;
   */
  syncPos?: SyncCookie;

  constructor(data?: PartialMessage<AddStreamToSyncRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.AddStreamToSyncRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sync_pos", kind: "message", T: SyncCookie },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddStreamToSyncRequest {
    return new AddStreamToSyncRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddStreamToSyncRequest {
    return new AddStreamToSyncRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddStreamToSyncRequest {
    return new AddStreamToSyncRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AddStreamToSyncRequest | PlainMessage<AddStreamToSyncRequest> | undefined, b: AddStreamToSyncRequest | PlainMessage<AddStreamToSyncRequest> | undefined): boolean {
    return proto3.util.equals(AddStreamToSyncRequest, a, b);
  }
}

/**
 * @generated from message river.AddStreamToSyncResponse
 */
export class AddStreamToSyncResponse extends Message<AddStreamToSyncResponse> {
  constructor(data?: PartialMessage<AddStreamToSyncResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.AddStreamToSyncResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddStreamToSyncResponse {
    return new AddStreamToSyncResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddStreamToSyncResponse {
    return new AddStreamToSyncResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddStreamToSyncResponse {
    return new AddStreamToSyncResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AddStreamToSyncResponse | PlainMessage<AddStreamToSyncResponse> | undefined, b: AddStreamToSyncResponse | PlainMessage<AddStreamToSyncResponse> | undefined): boolean {
    return proto3.util.equals(AddStreamToSyncResponse, a, b);
  }
}

/**
 * @generated from message river.RemoveStreamFromSyncRequest
 */
export class RemoveStreamFromSyncRequest extends Message<RemoveStreamFromSyncRequest> {
  /**
   * @generated from field: string sync_id = 1;
   */
  syncId = "";

  /**
   * @generated from field: bytes stream_id = 2;
   */
  streamId = new Uint8Array(0);

  constructor(data?: PartialMessage<RemoveStreamFromSyncRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.RemoveStreamFromSyncRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "stream_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveStreamFromSyncRequest {
    return new RemoveStreamFromSyncRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveStreamFromSyncRequest {
    return new RemoveStreamFromSyncRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveStreamFromSyncRequest {
    return new RemoveStreamFromSyncRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveStreamFromSyncRequest | PlainMessage<RemoveStreamFromSyncRequest> | undefined, b: RemoveStreamFromSyncRequest | PlainMessage<RemoveStreamFromSyncRequest> | undefined): boolean {
    return proto3.util.equals(RemoveStreamFromSyncRequest, a, b);
  }
}

/**
 * @generated from message river.RemoveStreamFromSyncResponse
 */
export class RemoveStreamFromSyncResponse extends Message<RemoveStreamFromSyncResponse> {
  constructor(data?: PartialMessage<RemoveStreamFromSyncResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.RemoveStreamFromSyncResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveStreamFromSyncResponse {
    return new RemoveStreamFromSyncResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveStreamFromSyncResponse {
    return new RemoveStreamFromSyncResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveStreamFromSyncResponse {
    return new RemoveStreamFromSyncResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveStreamFromSyncResponse | PlainMessage<RemoveStreamFromSyncResponse> | undefined, b: RemoveStreamFromSyncResponse | PlainMessage<RemoveStreamFromSyncResponse> | undefined): boolean {
    return proto3.util.equals(RemoveStreamFromSyncResponse, a, b);
  }
}

/**
 * @generated from message river.CancelSyncRequest
 */
export class CancelSyncRequest extends Message<CancelSyncRequest> {
  /**
   * @generated from field: string sync_id = 1;
   */
  syncId = "";

  constructor(data?: PartialMessage<CancelSyncRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.CancelSyncRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CancelSyncRequest {
    return new CancelSyncRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CancelSyncRequest {
    return new CancelSyncRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CancelSyncRequest {
    return new CancelSyncRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CancelSyncRequest | PlainMessage<CancelSyncRequest> | undefined, b: CancelSyncRequest | PlainMessage<CancelSyncRequest> | undefined): boolean {
    return proto3.util.equals(CancelSyncRequest, a, b);
  }
}

/**
 * @generated from message river.CancelSyncResponse
 */
export class CancelSyncResponse extends Message<CancelSyncResponse> {
  constructor(data?: PartialMessage<CancelSyncResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.CancelSyncResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CancelSyncResponse {
    return new CancelSyncResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CancelSyncResponse {
    return new CancelSyncResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CancelSyncResponse {
    return new CancelSyncResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CancelSyncResponse | PlainMessage<CancelSyncResponse> | undefined, b: CancelSyncResponse | PlainMessage<CancelSyncResponse> | undefined): boolean {
    return proto3.util.equals(CancelSyncResponse, a, b);
  }
}

/**
 * @generated from message river.PingSyncRequest
 */
export class PingSyncRequest extends Message<PingSyncRequest> {
  /**
   * @generated from field: string sync_id = 1;
   */
  syncId = "";

  /**
   * @generated from field: string nonce = 2;
   */
  nonce = "";

  constructor(data?: PartialMessage<PingSyncRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.PingSyncRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nonce", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PingSyncRequest {
    return new PingSyncRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PingSyncRequest {
    return new PingSyncRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PingSyncRequest {
    return new PingSyncRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PingSyncRequest | PlainMessage<PingSyncRequest> | undefined, b: PingSyncRequest | PlainMessage<PingSyncRequest> | undefined): boolean {
    return proto3.util.equals(PingSyncRequest, a, b);
  }
}

/**
 * @generated from message river.PingSyncResponse
 */
export class PingSyncResponse extends Message<PingSyncResponse> {
  constructor(data?: PartialMessage<PingSyncResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.PingSyncResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PingSyncResponse {
    return new PingSyncResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PingSyncResponse {
    return new PingSyncResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PingSyncResponse {
    return new PingSyncResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PingSyncResponse | PlainMessage<PingSyncResponse> | undefined, b: PingSyncResponse | PlainMessage<PingSyncResponse> | undefined): boolean {
    return proto3.util.equals(PingSyncResponse, a, b);
  }
}

/**
 * @generated from message river.InfoRequest
 */
export class InfoRequest extends Message<InfoRequest> {
  /**
   * @generated from field: repeated string debug = 1;
   */
  debug: string[] = [];

  constructor(data?: PartialMessage<InfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.InfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "debug", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InfoRequest {
    return new InfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InfoRequest {
    return new InfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InfoRequest {
    return new InfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: InfoRequest | PlainMessage<InfoRequest> | undefined, b: InfoRequest | PlainMessage<InfoRequest> | undefined): boolean {
    return proto3.util.equals(InfoRequest, a, b);
  }
}

/**
 * @generated from message river.InfoResponse
 */
export class InfoResponse extends Message<InfoResponse> {
  /**
   * @generated from field: string graffiti = 1;
   */
  graffiti = "";

  /**
   * @generated from field: google.protobuf.Timestamp start_time = 2;
   */
  startTime?: Timestamp;

  /**
   * @generated from field: string version = 3;
   */
  version = "";

  constructor(data?: PartialMessage<InfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "river.InfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "graffiti", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start_time", kind: "message", T: Timestamp },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InfoResponse {
    return new InfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InfoResponse {
    return new InfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InfoResponse {
    return new InfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: InfoResponse | PlainMessage<InfoResponse> | undefined, b: InfoResponse | PlainMessage<InfoResponse> | undefined): boolean {
    return proto3.util.equals(InfoResponse, a, b);
  }
}

